#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py:new_style
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException

from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class Aminoacid(object):
  Aminoacid__ = 0
  Aminoacid_A = 1
  Aminoacid_Ala = 2
  Aminoacid_Arg = 3
  Aminoacid_Asn = 4
  Aminoacid_Asp = 5
  Aminoacid_C = 6
  Aminoacid_Cys = 7
  Aminoacid_D = 8
  Aminoacid_E = 9
  Aminoacid_F = 10
  Aminoacid_G = 11
  Aminoacid_Gln = 12
  Aminoacid_Glu = 13
  Aminoacid_Gly = 14
  Aminoacid_H = 15
  Aminoacid_His = 16
  Aminoacid_I = 17
  Aminoacid_Ile = 18
  Aminoacid_K = 19
  Aminoacid_L = 20
  Aminoacid_Leu = 21
  Aminoacid_Lys = 22
  Aminoacid_M = 23
  Aminoacid_Met = 24
  Aminoacid_N = 25
  Aminoacid_P = 26
  Aminoacid_Phe = 27
  Aminoacid_Pro = 28
  Aminoacid_Q = 29
  Aminoacid_R = 30
  Aminoacid_S = 31
  Aminoacid_Ser = 32
  Aminoacid_Stop = 33
  Aminoacid_T = 34
  Aminoacid_Thr = 35
  Aminoacid_Trp = 36
  Aminoacid_Tyr = 37
  Aminoacid_V = 38
  Aminoacid_Val = 39
  Aminoacid_W = 40
  Aminoacid_X = 41
  Aminoacid_Y = 42
  Aminoacid_a = 43
  Aminoacid_c = 44
  Aminoacid_d = 45
  Aminoacid_e = 46
  Aminoacid_f = 47
  Aminoacid_g = 48
  Aminoacid_h = 49
  Aminoacid_i = 50
  Aminoacid_k = 51
  Aminoacid_l = 52
  Aminoacid_m = 53
  Aminoacid_n = 54
  Aminoacid_p = 55
  Aminoacid_q = 56
  Aminoacid_r = 57
  Aminoacid_s = 58
  Aminoacid_t = 59
  Aminoacid_v = 60
  Aminoacid_w = 61
  Aminoacid_x = 62
  Aminoacid_y = 63

  _VALUES_TO_NAMES = {
    0: "Aminoacid__",
    1: "Aminoacid_A",
    2: "Aminoacid_Ala",
    3: "Aminoacid_Arg",
    4: "Aminoacid_Asn",
    5: "Aminoacid_Asp",
    6: "Aminoacid_C",
    7: "Aminoacid_Cys",
    8: "Aminoacid_D",
    9: "Aminoacid_E",
    10: "Aminoacid_F",
    11: "Aminoacid_G",
    12: "Aminoacid_Gln",
    13: "Aminoacid_Glu",
    14: "Aminoacid_Gly",
    15: "Aminoacid_H",
    16: "Aminoacid_His",
    17: "Aminoacid_I",
    18: "Aminoacid_Ile",
    19: "Aminoacid_K",
    20: "Aminoacid_L",
    21: "Aminoacid_Leu",
    22: "Aminoacid_Lys",
    23: "Aminoacid_M",
    24: "Aminoacid_Met",
    25: "Aminoacid_N",
    26: "Aminoacid_P",
    27: "Aminoacid_Phe",
    28: "Aminoacid_Pro",
    29: "Aminoacid_Q",
    30: "Aminoacid_R",
    31: "Aminoacid_S",
    32: "Aminoacid_Ser",
    33: "Aminoacid_Stop",
    34: "Aminoacid_T",
    35: "Aminoacid_Thr",
    36: "Aminoacid_Trp",
    37: "Aminoacid_Tyr",
    38: "Aminoacid_V",
    39: "Aminoacid_Val",
    40: "Aminoacid_W",
    41: "Aminoacid_X",
    42: "Aminoacid_Y",
    43: "Aminoacid_a",
    44: "Aminoacid_c",
    45: "Aminoacid_d",
    46: "Aminoacid_e",
    47: "Aminoacid_f",
    48: "Aminoacid_g",
    49: "Aminoacid_h",
    50: "Aminoacid_i",
    51: "Aminoacid_k",
    52: "Aminoacid_l",
    53: "Aminoacid_m",
    54: "Aminoacid_n",
    55: "Aminoacid_p",
    56: "Aminoacid_q",
    57: "Aminoacid_r",
    58: "Aminoacid_s",
    59: "Aminoacid_t",
    60: "Aminoacid_v",
    61: "Aminoacid_w",
    62: "Aminoacid_x",
    63: "Aminoacid_y",
  }

  _NAMES_TO_VALUES = {
    "Aminoacid__": 0,
    "Aminoacid_A": 1,
    "Aminoacid_Ala": 2,
    "Aminoacid_Arg": 3,
    "Aminoacid_Asn": 4,
    "Aminoacid_Asp": 5,
    "Aminoacid_C": 6,
    "Aminoacid_Cys": 7,
    "Aminoacid_D": 8,
    "Aminoacid_E": 9,
    "Aminoacid_F": 10,
    "Aminoacid_G": 11,
    "Aminoacid_Gln": 12,
    "Aminoacid_Glu": 13,
    "Aminoacid_Gly": 14,
    "Aminoacid_H": 15,
    "Aminoacid_His": 16,
    "Aminoacid_I": 17,
    "Aminoacid_Ile": 18,
    "Aminoacid_K": 19,
    "Aminoacid_L": 20,
    "Aminoacid_Leu": 21,
    "Aminoacid_Lys": 22,
    "Aminoacid_M": 23,
    "Aminoacid_Met": 24,
    "Aminoacid_N": 25,
    "Aminoacid_P": 26,
    "Aminoacid_Phe": 27,
    "Aminoacid_Pro": 28,
    "Aminoacid_Q": 29,
    "Aminoacid_R": 30,
    "Aminoacid_S": 31,
    "Aminoacid_Ser": 32,
    "Aminoacid_Stop": 33,
    "Aminoacid_T": 34,
    "Aminoacid_Thr": 35,
    "Aminoacid_Trp": 36,
    "Aminoacid_Tyr": 37,
    "Aminoacid_V": 38,
    "Aminoacid_Val": 39,
    "Aminoacid_W": 40,
    "Aminoacid_X": 41,
    "Aminoacid_Y": 42,
    "Aminoacid_a": 43,
    "Aminoacid_c": 44,
    "Aminoacid_d": 45,
    "Aminoacid_e": 46,
    "Aminoacid_f": 47,
    "Aminoacid_g": 48,
    "Aminoacid_h": 49,
    "Aminoacid_i": 50,
    "Aminoacid_k": 51,
    "Aminoacid_l": 52,
    "Aminoacid_m": 53,
    "Aminoacid_n": 54,
    "Aminoacid_p": 55,
    "Aminoacid_q": 56,
    "Aminoacid_r": 57,
    "Aminoacid_s": 58,
    "Aminoacid_t": 59,
    "Aminoacid_v": 60,
    "Aminoacid_w": 61,
    "Aminoacid_x": 62,
    "Aminoacid_y": 63,
  }

class Nucleotide_ambiguous(object):
  Nucleotide_ambiguous_B = 0
  Nucleotide_ambiguous_D = 1
  Nucleotide_ambiguous_H = 2
  Nucleotide_ambiguous_K = 3
  Nucleotide_ambiguous_M = 4
  Nucleotide_ambiguous_N = 5
  Nucleotide_ambiguous_R = 6
  Nucleotide_ambiguous_S = 7
  Nucleotide_ambiguous_V = 8
  Nucleotide_ambiguous_W = 9
  Nucleotide_ambiguous_Y = 10
  Nucleotide_ambiguous_b = 11
  Nucleotide_ambiguous_d = 12
  Nucleotide_ambiguous_h = 13
  Nucleotide_ambiguous_k = 14
  Nucleotide_ambiguous_m = 15
  Nucleotide_ambiguous_n = 16
  Nucleotide_ambiguous_r = 17
  Nucleotide_ambiguous_s = 18
  Nucleotide_ambiguous_v = 19
  Nucleotide_ambiguous_w = 20
  Nucleotide_ambiguous_y = 21

  _VALUES_TO_NAMES = {
    0: "Nucleotide_ambiguous_B",
    1: "Nucleotide_ambiguous_D",
    2: "Nucleotide_ambiguous_H",
    3: "Nucleotide_ambiguous_K",
    4: "Nucleotide_ambiguous_M",
    5: "Nucleotide_ambiguous_N",
    6: "Nucleotide_ambiguous_R",
    7: "Nucleotide_ambiguous_S",
    8: "Nucleotide_ambiguous_V",
    9: "Nucleotide_ambiguous_W",
    10: "Nucleotide_ambiguous_Y",
    11: "Nucleotide_ambiguous_b",
    12: "Nucleotide_ambiguous_d",
    13: "Nucleotide_ambiguous_h",
    14: "Nucleotide_ambiguous_k",
    15: "Nucleotide_ambiguous_m",
    16: "Nucleotide_ambiguous_n",
    17: "Nucleotide_ambiguous_r",
    18: "Nucleotide_ambiguous_s",
    19: "Nucleotide_ambiguous_v",
    20: "Nucleotide_ambiguous_w",
    21: "Nucleotide_ambiguous_y",
  }

  _NAMES_TO_VALUES = {
    "Nucleotide_ambiguous_B": 0,
    "Nucleotide_ambiguous_D": 1,
    "Nucleotide_ambiguous_H": 2,
    "Nucleotide_ambiguous_K": 3,
    "Nucleotide_ambiguous_M": 4,
    "Nucleotide_ambiguous_N": 5,
    "Nucleotide_ambiguous_R": 6,
    "Nucleotide_ambiguous_S": 7,
    "Nucleotide_ambiguous_V": 8,
    "Nucleotide_ambiguous_W": 9,
    "Nucleotide_ambiguous_Y": 10,
    "Nucleotide_ambiguous_b": 11,
    "Nucleotide_ambiguous_d": 12,
    "Nucleotide_ambiguous_h": 13,
    "Nucleotide_ambiguous_k": 14,
    "Nucleotide_ambiguous_m": 15,
    "Nucleotide_ambiguous_n": 16,
    "Nucleotide_ambiguous_r": 17,
    "Nucleotide_ambiguous_s": 18,
    "Nucleotide_ambiguous_v": 19,
    "Nucleotide_ambiguous_w": 20,
    "Nucleotide_ambiguous_y": 21,
  }

class Nucleotide_defined(object):
  Nucleotide_defined_A = 0
  Nucleotide_defined_C = 1
  Nucleotide_defined_G = 2
  Nucleotide_defined_T = 3
  Nucleotide_defined_U = 4
  Nucleotide_defined_a = 5
  Nucleotide_defined_c = 6
  Nucleotide_defined_g = 7
  Nucleotide_defined_t = 8
  Nucleotide_defined_u = 9

  _VALUES_TO_NAMES = {
    0: "Nucleotide_defined_A",
    1: "Nucleotide_defined_C",
    2: "Nucleotide_defined_G",
    3: "Nucleotide_defined_T",
    4: "Nucleotide_defined_U",
    5: "Nucleotide_defined_a",
    6: "Nucleotide_defined_c",
    7: "Nucleotide_defined_g",
    8: "Nucleotide_defined_t",
    9: "Nucleotide_defined_u",
  }

  _NAMES_TO_VALUES = {
    "Nucleotide_defined_A": 0,
    "Nucleotide_defined_C": 1,
    "Nucleotide_defined_G": 2,
    "Nucleotide_defined_T": 3,
    "Nucleotide_defined_U": 4,
    "Nucleotide_defined_a": 5,
    "Nucleotide_defined_c": 6,
    "Nucleotide_defined_g": 7,
    "Nucleotide_defined_t": 8,
    "Nucleotide_defined_u": 9,
  }

class Segment_type(object):
  Segment_type_D = 0
  Segment_type_J = 1
  Segment_type_V = 2

  _VALUES_TO_NAMES = {
    0: "Segment_type_D",
    1: "Segment_type_J",
    2: "Segment_type_V",
  }

  _NAMES_TO_VALUES = {
    "Segment_type_D": 0,
    "Segment_type_J": 1,
    "Segment_type_V": 2,
  }


class UnspecifiedType(object):
  """
  Attributes:
   - baseObjectType
   - object
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'baseObjectType', None, None, ), # 1
    (2, TType.STRING, 'object', None, None, ), # 2
  )

  def __init__(self, baseObjectType=None, object=None,):
    self.baseObjectType = baseObjectType
    self.object = object

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.baseObjectType = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.object = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('UnspecifiedType')
    if self.baseObjectType is not None:
      oprot.writeFieldBegin('baseObjectType', TType.STRING, 1)
      oprot.writeString(self.baseObjectType)
      oprot.writeFieldEnd()
    if self.object is not None:
      oprot.writeFieldBegin('object', TType.STRING, 2)
      oprot.writeString(self.object)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.baseObjectType is None:
      raise TProtocol.TProtocolException(message='Required field baseObjectType is unset!')
    if self.object is None:
      raise TProtocol.TProtocolException(message='Required field object is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.baseObjectType)
    value = (value * 31) ^ hash(self.object)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class aa_substitutionType(object):
  """
  Attributes:
   - gl_aa
   - read_aa
   - read_pos0
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'gl_aa', None, None, ), # 1
    (2, TType.I32, 'read_aa', None, None, ), # 2
    (3, TType.I64, 'read_pos0', None, None, ), # 3
  )

  def __init__(self, gl_aa=None, read_aa=None, read_pos0=None,):
    self.gl_aa = gl_aa
    self.read_aa = read_aa
    self.read_pos0 = read_pos0

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.gl_aa = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.read_aa = iprot.readI32()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.read_pos0 = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('aa_substitutionType')
    if self.gl_aa is not None:
      oprot.writeFieldBegin('gl_aa', TType.I32, 1)
      oprot.writeI32(self.gl_aa)
      oprot.writeFieldEnd()
    if self.read_aa is not None:
      oprot.writeFieldBegin('read_aa', TType.I32, 2)
      oprot.writeI32(self.read_aa)
      oprot.writeFieldEnd()
    if self.read_pos0 is not None:
      oprot.writeFieldBegin('read_pos0', TType.I64, 3)
      oprot.writeI64(self.read_pos0)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.gl_aa is None:
      raise TProtocol.TProtocolException(message='Required field gl_aa is unset!')
    if self.read_aa is None:
      raise TProtocol.TProtocolException(message='Required field read_aa is unset!')
    if self.read_pos0 is None:
      raise TProtocol.TProtocolException(message='Required field read_pos0 is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.gl_aa)
    value = (value * 31) ^ hash(self.read_aa)
    value = (value * 31) ^ hash(self.read_pos0)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class alignerType(object):
  """
  Attributes:
   - aligner_id
   - name
   - parameters
   - run_id
   - uri
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'aligner_id', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'parameters', None, None, ), # 3
    (4, TType.I64, 'run_id', None, None, ), # 4
    (5, TType.STRUCT, 'uri', (UnspecifiedType, UnspecifiedType.thrift_spec), None, ), # 5
    (6, TType.STRING, 'version', None, None, ), # 6
  )

  def __init__(self, aligner_id=None, name=None, parameters=None, run_id=None, uri=None, version=None,):
    self.aligner_id = aligner_id
    self.name = name
    self.parameters = parameters
    self.run_id = run_id
    self.uri = uri
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.aligner_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.parameters = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.run_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.uri = UnspecifiedType()
          self.uri.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('alignerType')
    if self.aligner_id is not None:
      oprot.writeFieldBegin('aligner_id', TType.I64, 1)
      oprot.writeI64(self.aligner_id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.parameters is not None:
      oprot.writeFieldBegin('parameters', TType.STRING, 3)
      oprot.writeString(self.parameters)
      oprot.writeFieldEnd()
    if self.run_id is not None:
      oprot.writeFieldBegin('run_id', TType.I64, 4)
      oprot.writeI64(self.run_id)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRUCT, 5)
      self.uri.write(oprot)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 6)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.aligner_id is None:
      raise TProtocol.TProtocolException(message='Required field aligner_id is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.aligner_id)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.parameters)
    value = (value * 31) ^ hash(self.run_id)
    value = (value * 31) ^ hash(self.uri)
    value = (value * 31) ^ hash(self.version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class generatorType(object):
  """
  Attributes:
   - name
   - time_gmt
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.I64, 'time_gmt', None, None, ), # 2
    (3, TType.STRING, 'version', None, None, ), # 3
  )

  def __init__(self, name=None, time_gmt=None, version=None,):
    self.name = name
    self.time_gmt = time_gmt
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.time_gmt = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('generatorType')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.time_gmt is not None:
      oprot.writeFieldBegin('time_gmt', TType.I64, 2)
      oprot.writeI64(self.time_gmt)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 3)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.time_gmt is None:
      raise TProtocol.TProtocolException(message='Required field time_gmt is unset!')
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.time_gmt)
    value = (value * 31) ^ hash(self.version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class germline_dbType(object):
  """
  Attributes:
   - gl_db_id
   - name
   - species
   - uri
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'gl_db_id', None, None, ), # 1
    (2, TType.STRING, 'name', None, None, ), # 2
    (3, TType.STRING, 'species', None, None, ), # 3
    (4, TType.STRUCT, 'uri', (UnspecifiedType, UnspecifiedType.thrift_spec), None, ), # 4
    (5, TType.STRING, 'version', None, None, ), # 5
  )

  def __init__(self, gl_db_id=None, name=None, species=None, uri=None, version=None,):
    self.gl_db_id = gl_db_id
    self.name = name
    self.species = species
    self.uri = uri
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.gl_db_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.species = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.uri = UnspecifiedType()
          self.uri.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.version = iprot.readString()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('germline_dbType')
    if self.gl_db_id is not None:
      oprot.writeFieldBegin('gl_db_id', TType.I64, 1)
      oprot.writeI64(self.gl_db_id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 2)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.species is not None:
      oprot.writeFieldBegin('species', TType.STRING, 3)
      oprot.writeString(self.species)
      oprot.writeFieldEnd()
    if self.uri is not None:
      oprot.writeFieldBegin('uri', TType.STRUCT, 4)
      self.uri.write(oprot)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.STRING, 5)
      oprot.writeString(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.gl_db_id is None:
      raise TProtocol.TProtocolException(message='Required field gl_db_id is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.species is None:
      raise TProtocol.TProtocolException(message='Required field species is unset!')
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.gl_db_id)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.species)
    value = (value * 31) ^ hash(self.uri)
    value = (value * 31) ^ hash(self.version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class gl_seg_matchType(object):
  """
  Attributes:
   - aligner_id
   - gl_db_id
   - gl_pos0
   - gl_seg_match_id
   - name
   - num_system
   - type
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'aligner_id', None, None, ), # 1
    (2, TType.I64, 'gl_db_id', None, None, ), # 2
    (3, TType.I64, 'gl_pos0', None, None, ), # 3
    (4, TType.I64, 'gl_seg_match_id', None, None, ), # 4
    (5, TType.STRING, 'name', None, None, ), # 5
    (6, TType.STRING, 'num_system', None, None, ), # 6
    (7, TType.I32, 'type', None, None, ), # 7
  )

  def __init__(self, aligner_id=None, gl_db_id=None, gl_pos0=None, gl_seg_match_id=None, name=None, num_system=None, type=None,):
    self.aligner_id = aligner_id
    self.gl_db_id = gl_db_id
    self.gl_pos0 = gl_pos0
    self.gl_seg_match_id = gl_seg_match_id
    self.name = name
    self.num_system = num_system
    self.type = type

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.aligner_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.gl_db_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.gl_pos0 = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.gl_seg_match_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.num_system = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I32:
          self.type = iprot.readI32()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('gl_seg_matchType')
    if self.aligner_id is not None:
      oprot.writeFieldBegin('aligner_id', TType.I64, 1)
      oprot.writeI64(self.aligner_id)
      oprot.writeFieldEnd()
    if self.gl_db_id is not None:
      oprot.writeFieldBegin('gl_db_id', TType.I64, 2)
      oprot.writeI64(self.gl_db_id)
      oprot.writeFieldEnd()
    if self.gl_pos0 is not None:
      oprot.writeFieldBegin('gl_pos0', TType.I64, 3)
      oprot.writeI64(self.gl_pos0)
      oprot.writeFieldEnd()
    if self.gl_seg_match_id is not None:
      oprot.writeFieldBegin('gl_seg_match_id', TType.I64, 4)
      oprot.writeI64(self.gl_seg_match_id)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 5)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.num_system is not None:
      oprot.writeFieldBegin('num_system', TType.STRING, 6)
      oprot.writeString(self.num_system)
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 7)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.aligner_id is None:
      raise TProtocol.TProtocolException(message='Required field aligner_id is unset!')
    if self.gl_db_id is None:
      raise TProtocol.TProtocolException(message='Required field gl_db_id is unset!')
    if self.gl_pos0 is None:
      raise TProtocol.TProtocolException(message='Required field gl_pos0 is unset!')
    if self.gl_seg_match_id is None:
      raise TProtocol.TProtocolException(message='Required field gl_seg_match_id is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.num_system is None:
      raise TProtocol.TProtocolException(message='Required field num_system is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.aligner_id)
    value = (value * 31) ^ hash(self.gl_db_id)
    value = (value * 31) ^ hash(self.gl_pos0)
    value = (value * 31) ^ hash(self.gl_seg_match_id)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.num_system)
    value = (value * 31) ^ hash(self.type)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class metaType(object):
  """
  Attributes:
   - aligner
   - generator
   - germline_db
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'aligner', (alignerType, alignerType.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'generator', (generatorType, generatorType.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'germline_db', (germline_dbType, germline_dbType.thrift_spec), None, ), # 3
  )

  def __init__(self, aligner=None, generator=None, germline_db=None,):
    self.aligner = aligner
    self.generator = generator
    self.germline_db = germline_db

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.aligner = alignerType()
          self.aligner.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.generator = generatorType()
          self.generator.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.germline_db = germline_dbType()
          self.germline_db.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('metaType')
    if self.aligner is not None:
      oprot.writeFieldBegin('aligner', TType.STRUCT, 1)
      self.aligner.write(oprot)
      oprot.writeFieldEnd()
    if self.generator is not None:
      oprot.writeFieldBegin('generator', TType.STRUCT, 2)
      self.generator.write(oprot)
      oprot.writeFieldEnd()
    if self.germline_db is not None:
      oprot.writeFieldBegin('germline_db', TType.STRUCT, 3)
      self.germline_db.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.generator is None:
      raise TProtocol.TProtocolException(message='Required field generator is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.aligner)
    value = (value * 31) ^ hash(self.generator)
    value = (value * 31) ^ hash(self.germline_db)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class regionType(object):
  """
  Attributes:
   - aligner_id
   - deletions
   - identity
   - insertions
   - inverted
   - mutated_invariant
   - name
   - num_system
   - out_frame_indel
   - out_frame_vdj
   - read_len
   - read_pos0
   - score
   - stop_codon
   - substitutions
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'aligner_id', None, None, ), # 1
    (2, TType.I64, 'deletions', None, None, ), # 2
    (3, TType.STRING, 'identity', None, None, ), # 3
    (4, TType.I64, 'insertions', None, None, ), # 4
    (5, TType.BOOL, 'inverted', None, None, ), # 5
    (6, TType.BOOL, 'mutated_invariant', None, None, ), # 6
    (7, TType.STRING, 'name', None, None, ), # 7
    (8, TType.STRING, 'num_system', None, None, ), # 8
    (9, TType.BOOL, 'out_frame_indel', None, None, ), # 9
    (10, TType.BOOL, 'out_frame_vdj', None, None, ), # 10
    (11, TType.I64, 'read_len', None, None, ), # 11
    (12, TType.I64, 'read_pos0', None, None, ), # 12
    (13, TType.I64, 'score', None, None, ), # 13
    (14, TType.BOOL, 'stop_codon', None, None, ), # 14
    (15, TType.I64, 'substitutions', None, None, ), # 15
  )

  def __init__(self, aligner_id=None, deletions=None, identity=None, insertions=None, inverted=None, mutated_invariant=None, name=None, num_system=None, out_frame_indel=None, out_frame_vdj=None, read_len=None, read_pos0=None, score=None, stop_codon=None, substitutions=None,):
    self.aligner_id = aligner_id
    self.deletions = deletions
    self.identity = identity
    self.insertions = insertions
    self.inverted = inverted
    self.mutated_invariant = mutated_invariant
    self.name = name
    self.num_system = num_system
    self.out_frame_indel = out_frame_indel
    self.out_frame_vdj = out_frame_vdj
    self.read_len = read_len
    self.read_pos0 = read_pos0
    self.score = score
    self.stop_codon = stop_codon
    self.substitutions = substitutions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.aligner_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.deletions = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRING:
          self.identity = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.insertions = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.inverted = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.mutated_invariant = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRING:
          self.name = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRING:
          self.num_system = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.out_frame_indel = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.out_frame_vdj = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.I64:
          self.read_len = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.read_pos0 = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.score = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.BOOL:
          self.stop_codon = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.substitutions = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('regionType')
    if self.aligner_id is not None:
      oprot.writeFieldBegin('aligner_id', TType.I64, 1)
      oprot.writeI64(self.aligner_id)
      oprot.writeFieldEnd()
    if self.deletions is not None:
      oprot.writeFieldBegin('deletions', TType.I64, 2)
      oprot.writeI64(self.deletions)
      oprot.writeFieldEnd()
    if self.identity is not None:
      oprot.writeFieldBegin('identity', TType.STRING, 3)
      oprot.writeString(self.identity)
      oprot.writeFieldEnd()
    if self.insertions is not None:
      oprot.writeFieldBegin('insertions', TType.I64, 4)
      oprot.writeI64(self.insertions)
      oprot.writeFieldEnd()
    if self.inverted is not None:
      oprot.writeFieldBegin('inverted', TType.BOOL, 5)
      oprot.writeBool(self.inverted)
      oprot.writeFieldEnd()
    if self.mutated_invariant is not None:
      oprot.writeFieldBegin('mutated_invariant', TType.BOOL, 6)
      oprot.writeBool(self.mutated_invariant)
      oprot.writeFieldEnd()
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 7)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.num_system is not None:
      oprot.writeFieldBegin('num_system', TType.STRING, 8)
      oprot.writeString(self.num_system)
      oprot.writeFieldEnd()
    if self.out_frame_indel is not None:
      oprot.writeFieldBegin('out_frame_indel', TType.BOOL, 9)
      oprot.writeBool(self.out_frame_indel)
      oprot.writeFieldEnd()
    if self.out_frame_vdj is not None:
      oprot.writeFieldBegin('out_frame_vdj', TType.BOOL, 10)
      oprot.writeBool(self.out_frame_vdj)
      oprot.writeFieldEnd()
    if self.read_len is not None:
      oprot.writeFieldBegin('read_len', TType.I64, 11)
      oprot.writeI64(self.read_len)
      oprot.writeFieldEnd()
    if self.read_pos0 is not None:
      oprot.writeFieldBegin('read_pos0', TType.I64, 12)
      oprot.writeI64(self.read_pos0)
      oprot.writeFieldEnd()
    if self.score is not None:
      oprot.writeFieldBegin('score', TType.I64, 13)
      oprot.writeI64(self.score)
      oprot.writeFieldEnd()
    if self.stop_codon is not None:
      oprot.writeFieldBegin('stop_codon', TType.BOOL, 14)
      oprot.writeBool(self.stop_codon)
      oprot.writeFieldEnd()
    if self.substitutions is not None:
      oprot.writeFieldBegin('substitutions', TType.I64, 15)
      oprot.writeI64(self.substitutions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.aligner_id is None:
      raise TProtocol.TProtocolException(message='Required field aligner_id is unset!')
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.read_len is None:
      raise TProtocol.TProtocolException(message='Required field read_len is unset!')
    if self.read_pos0 is None:
      raise TProtocol.TProtocolException(message='Required field read_pos0 is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.aligner_id)
    value = (value * 31) ^ hash(self.deletions)
    value = (value * 31) ^ hash(self.identity)
    value = (value * 31) ^ hash(self.insertions)
    value = (value * 31) ^ hash(self.inverted)
    value = (value * 31) ^ hash(self.mutated_invariant)
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.num_system)
    value = (value * 31) ^ hash(self.out_frame_indel)
    value = (value * 31) ^ hash(self.out_frame_vdj)
    value = (value * 31) ^ hash(self.read_len)
    value = (value * 31) ^ hash(self.read_pos0)
    value = (value * 31) ^ hash(self.score)
    value = (value * 31) ^ hash(self.stop_codon)
    value = (value * 31) ^ hash(self.substitutions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class segment_matchType(object):
  """
  Attributes:
   - aa_substitution
   - btop
   - deletions
   - gl_len
   - gl_seg_match
   - identity
   - insertions
   - inverted
   - mutated_invariant
   - out_frame_indel
   - out_frame_vdj
   - read_len
   - read_pos0
   - score
   - segment_match_id
   - stop_codon
   - substitutions
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'aa_substitution', (TType.STRUCT,(aa_substitutionType, aa_substitutionType.thrift_spec)), None, ), # 1
    (2, TType.STRING, 'btop', None, None, ), # 2
    (3, TType.I64, 'deletions', None, None, ), # 3
    (4, TType.I64, 'gl_len', None, None, ), # 4
    (5, TType.LIST, 'gl_seg_match', (TType.STRUCT,(gl_seg_matchType, gl_seg_matchType.thrift_spec)), None, ), # 5
    (6, TType.STRING, 'identity', None, None, ), # 6
    (7, TType.I64, 'insertions', None, None, ), # 7
    (8, TType.BOOL, 'inverted', None, None, ), # 8
    (9, TType.BOOL, 'mutated_invariant', None, None, ), # 9
    (10, TType.BOOL, 'out_frame_indel', None, None, ), # 10
    (11, TType.BOOL, 'out_frame_vdj', None, None, ), # 11
    (12, TType.I64, 'read_len', None, None, ), # 12
    (13, TType.I64, 'read_pos0', None, None, ), # 13
    (14, TType.I64, 'score', None, None, ), # 14
    (15, TType.I64, 'segment_match_id', None, None, ), # 15
    (16, TType.BOOL, 'stop_codon', None, None, ), # 16
    (17, TType.I64, 'substitutions', None, None, ), # 17
  )

  def __init__(self, aa_substitution=None, btop=None, deletions=None, gl_len=None, gl_seg_match=None, identity=None, insertions=None, inverted=None, mutated_invariant=None, out_frame_indel=None, out_frame_vdj=None, read_len=None, read_pos0=None, score=None, segment_match_id=None, stop_codon=None, substitutions=None,):
    self.aa_substitution = aa_substitution
    self.btop = btop
    self.deletions = deletions
    self.gl_len = gl_len
    self.gl_seg_match = gl_seg_match
    self.identity = identity
    self.insertions = insertions
    self.inverted = inverted
    self.mutated_invariant = mutated_invariant
    self.out_frame_indel = out_frame_indel
    self.out_frame_vdj = out_frame_vdj
    self.read_len = read_len
    self.read_pos0 = read_pos0
    self.score = score
    self.segment_match_id = segment_match_id
    self.stop_codon = stop_codon
    self.substitutions = substitutions

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.aa_substitution = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = aa_substitutionType()
            _elem5.read(iprot)
            self.aa_substitution.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.btop = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.deletions = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.gl_len = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.LIST:
          self.gl_seg_match = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = gl_seg_matchType()
            _elem11.read(iprot)
            self.gl_seg_match.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRING:
          self.identity = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I64:
          self.insertions = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BOOL:
          self.inverted = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BOOL:
          self.mutated_invariant = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BOOL:
          self.out_frame_indel = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BOOL:
          self.out_frame_vdj = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I64:
          self.read_len = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.I64:
          self.read_pos0 = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.I64:
          self.score = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.I64:
          self.segment_match_id = iprot.readI64()
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.BOOL:
          self.stop_codon = iprot.readBool()
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.I64:
          self.substitutions = iprot.readI64()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('segment_matchType')
    if self.aa_substitution is not None:
      oprot.writeFieldBegin('aa_substitution', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.aa_substitution))
      for iter12 in self.aa_substitution:
        iter12.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.btop is not None:
      oprot.writeFieldBegin('btop', TType.STRING, 2)
      oprot.writeString(self.btop)
      oprot.writeFieldEnd()
    if self.deletions is not None:
      oprot.writeFieldBegin('deletions', TType.I64, 3)
      oprot.writeI64(self.deletions)
      oprot.writeFieldEnd()
    if self.gl_len is not None:
      oprot.writeFieldBegin('gl_len', TType.I64, 4)
      oprot.writeI64(self.gl_len)
      oprot.writeFieldEnd()
    if self.gl_seg_match is not None:
      oprot.writeFieldBegin('gl_seg_match', TType.LIST, 5)
      oprot.writeListBegin(TType.STRUCT, len(self.gl_seg_match))
      for iter13 in self.gl_seg_match:
        iter13.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.identity is not None:
      oprot.writeFieldBegin('identity', TType.STRING, 6)
      oprot.writeString(self.identity)
      oprot.writeFieldEnd()
    if self.insertions is not None:
      oprot.writeFieldBegin('insertions', TType.I64, 7)
      oprot.writeI64(self.insertions)
      oprot.writeFieldEnd()
    if self.inverted is not None:
      oprot.writeFieldBegin('inverted', TType.BOOL, 8)
      oprot.writeBool(self.inverted)
      oprot.writeFieldEnd()
    if self.mutated_invariant is not None:
      oprot.writeFieldBegin('mutated_invariant', TType.BOOL, 9)
      oprot.writeBool(self.mutated_invariant)
      oprot.writeFieldEnd()
    if self.out_frame_indel is not None:
      oprot.writeFieldBegin('out_frame_indel', TType.BOOL, 10)
      oprot.writeBool(self.out_frame_indel)
      oprot.writeFieldEnd()
    if self.out_frame_vdj is not None:
      oprot.writeFieldBegin('out_frame_vdj', TType.BOOL, 11)
      oprot.writeBool(self.out_frame_vdj)
      oprot.writeFieldEnd()
    if self.read_len is not None:
      oprot.writeFieldBegin('read_len', TType.I64, 12)
      oprot.writeI64(self.read_len)
      oprot.writeFieldEnd()
    if self.read_pos0 is not None:
      oprot.writeFieldBegin('read_pos0', TType.I64, 13)
      oprot.writeI64(self.read_pos0)
      oprot.writeFieldEnd()
    if self.score is not None:
      oprot.writeFieldBegin('score', TType.I64, 14)
      oprot.writeI64(self.score)
      oprot.writeFieldEnd()
    if self.segment_match_id is not None:
      oprot.writeFieldBegin('segment_match_id', TType.I64, 15)
      oprot.writeI64(self.segment_match_id)
      oprot.writeFieldEnd()
    if self.stop_codon is not None:
      oprot.writeFieldBegin('stop_codon', TType.BOOL, 16)
      oprot.writeBool(self.stop_codon)
      oprot.writeFieldEnd()
    if self.substitutions is not None:
      oprot.writeFieldBegin('substitutions', TType.I64, 17)
      oprot.writeI64(self.substitutions)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.btop is None:
      raise TProtocol.TProtocolException(message='Required field btop is unset!')
    if self.gl_len is None:
      raise TProtocol.TProtocolException(message='Required field gl_len is unset!')
    if self.gl_seg_match is None:
      raise TProtocol.TProtocolException(message='Required field gl_seg_match is unset!')
    if self.read_len is None:
      raise TProtocol.TProtocolException(message='Required field read_len is unset!')
    if self.read_pos0 is None:
      raise TProtocol.TProtocolException(message='Required field read_pos0 is unset!')
    if self.segment_match_id is None:
      raise TProtocol.TProtocolException(message='Required field segment_match_id is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.aa_substitution)
    value = (value * 31) ^ hash(self.btop)
    value = (value * 31) ^ hash(self.deletions)
    value = (value * 31) ^ hash(self.gl_len)
    value = (value * 31) ^ hash(self.gl_seg_match)
    value = (value * 31) ^ hash(self.identity)
    value = (value * 31) ^ hash(self.insertions)
    value = (value * 31) ^ hash(self.inverted)
    value = (value * 31) ^ hash(self.mutated_invariant)
    value = (value * 31) ^ hash(self.out_frame_indel)
    value = (value * 31) ^ hash(self.out_frame_vdj)
    value = (value * 31) ^ hash(self.read_len)
    value = (value * 31) ^ hash(self.read_pos0)
    value = (value * 31) ^ hash(self.score)
    value = (value * 31) ^ hash(self.segment_match_id)
    value = (value * 31) ^ hash(self.stop_codon)
    value = (value * 31) ^ hash(self.substitutions)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class combinationType(object):
  """
  Attributes:
   - region
   - segments
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'region', (TType.STRUCT,(regionType, regionType.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'segments', (TType.I64,None), None, ), # 2
  )

  def __init__(self, region=None, segments=None,):
    self.region = region
    self.segments = segments

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.region = []
          (_etype17, _size14) = iprot.readListBegin()
          for _i18 in xrange(_size14):
            _elem19 = regionType()
            _elem19.read(iprot)
            self.region.append(_elem19)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.segments = []
          (_etype23, _size20) = iprot.readListBegin()
          for _i24 in xrange(_size20):
            _elem25 = iprot.readI64()
            self.segments.append(_elem25)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('combinationType')
    if self.region is not None:
      oprot.writeFieldBegin('region', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.region))
      for iter26 in self.region:
        iter26.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.segments is not None:
      oprot.writeFieldBegin('segments', TType.LIST, 2)
      oprot.writeListBegin(TType.I64, len(self.segments))
      for iter27 in self.segments:
        oprot.writeI64(iter27)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.segments is None:
      raise TProtocol.TProtocolException(message='Required field segments is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.region)
    value = (value * 31) ^ hash(self.segments)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class vdj_alignmentType(object):
  """
  Attributes:
   - combination
   - segment_match
  """

  thrift_spec = (
    None, # 0
    (1, TType.LIST, 'combination', (TType.STRUCT,(combinationType, combinationType.thrift_spec)), None, ), # 1
    (2, TType.LIST, 'segment_match', (TType.STRUCT,(segment_matchType, segment_matchType.thrift_spec)), None, ), # 2
  )

  def __init__(self, combination=None, segment_match=None,):
    self.combination = combination
    self.segment_match = segment_match

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.LIST:
          self.combination = []
          (_etype31, _size28) = iprot.readListBegin()
          for _i32 in xrange(_size28):
            _elem33 = combinationType()
            _elem33.read(iprot)
            self.combination.append(_elem33)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.segment_match = []
          (_etype37, _size34) = iprot.readListBegin()
          for _i38 in xrange(_size34):
            _elem39 = segment_matchType()
            _elem39.read(iprot)
            self.segment_match.append(_elem39)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('vdj_alignmentType')
    if self.combination is not None:
      oprot.writeFieldBegin('combination', TType.LIST, 1)
      oprot.writeListBegin(TType.STRUCT, len(self.combination))
      for iter40 in self.combination:
        iter40.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.segment_match is not None:
      oprot.writeFieldBegin('segment_match', TType.LIST, 2)
      oprot.writeListBegin(TType.STRUCT, len(self.segment_match))
      for iter41 in self.segment_match:
        iter41.write(oprot)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.combination is None:
      raise TProtocol.TProtocolException(message='Required field combination is unset!')
    if self.segment_match is None:
      raise TProtocol.TProtocolException(message='Required field segment_match is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.combination)
    value = (value * 31) ^ hash(self.segment_match)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class readType(object):
  """
  Attributes:
   - read_id
   - vdj_alignment
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'read_id', None, None, ), # 1
    (2, TType.STRUCT, 'vdj_alignment', (vdj_alignmentType, vdj_alignmentType.thrift_spec), None, ), # 2
  )

  def __init__(self, read_id=None, vdj_alignment=None,):
    self.read_id = read_id
    self.vdj_alignment = vdj_alignment

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.read_id = iprot.readString()
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.vdj_alignment = vdj_alignmentType()
          self.vdj_alignment.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('readType')
    if self.read_id is not None:
      oprot.writeFieldBegin('read_id', TType.STRING, 1)
      oprot.writeString(self.read_id)
      oprot.writeFieldEnd()
    if self.vdj_alignment is not None:
      oprot.writeFieldBegin('vdj_alignment', TType.STRUCT, 2)
      self.vdj_alignment.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.read_id is None:
      raise TProtocol.TProtocolException(message='Required field read_id is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.read_id)
    value = (value * 31) ^ hash(self.vdj_alignment)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class read_resultsType(object):
  """
  Attributes:
   - read
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'read', (readType, readType.thrift_spec), None, ), # 1
  )

  def __init__(self, read=None,):
    self.read = read

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.read = readType()
          self.read.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('read_resultsType')
    if self.read is not None:
      oprot.writeFieldBegin('read', TType.STRUCT, 1)
      self.read.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.read is None:
      raise TProtocol.TProtocolException(message='Required field read is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.read)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class vdjmlType(object):
  """
  Attributes:
   - meta
   - read_results
   - version
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'meta', (metaType, metaType.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'read_results', (read_resultsType, read_resultsType.thrift_spec), None, ), # 2
    (3, TType.DOUBLE, 'version', None, None, ), # 3
  )

  def __init__(self, meta=None, read_results=None, version=None,):
    self.meta = meta
    self.read_results = read_results
    self.version = version

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.meta = metaType()
          self.meta.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.read_results = read_resultsType()
          self.read_results.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.version = iprot.readDouble()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('vdjmlType')
    if self.meta is not None:
      oprot.writeFieldBegin('meta', TType.STRUCT, 1)
      self.meta.write(oprot)
      oprot.writeFieldEnd()
    if self.read_results is not None:
      oprot.writeFieldBegin('read_results', TType.STRUCT, 2)
      self.read_results.write(oprot)
      oprot.writeFieldEnd()
    if self.version is not None:
      oprot.writeFieldBegin('version', TType.DOUBLE, 3)
      oprot.writeDouble(self.version)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta is None:
      raise TProtocol.TProtocolException(message='Required field meta is unset!')
    if self.read_results is None:
      raise TProtocol.TProtocolException(message='Required field read_results is unset!')
    if self.version is None:
      raise TProtocol.TProtocolException(message='Required field version is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta)
    value = (value * 31) ^ hash(self.read_results)
    value = (value * 31) ^ hash(self.version)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
