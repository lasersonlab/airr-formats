#
# Autogenerated by Thrift Compiler (0.9.3)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
require 5.6.0;
use strict;
use warnings;
use Thrift;

package vdjserver::Aminoacid;
use constant Aminoacid__ => 0;
use constant Aminoacid_A => 1;
use constant Aminoacid_Ala => 2;
use constant Aminoacid_Arg => 3;
use constant Aminoacid_Asn => 4;
use constant Aminoacid_Asp => 5;
use constant Aminoacid_C => 6;
use constant Aminoacid_Cys => 7;
use constant Aminoacid_D => 8;
use constant Aminoacid_E => 9;
use constant Aminoacid_F => 10;
use constant Aminoacid_G => 11;
use constant Aminoacid_Gln => 12;
use constant Aminoacid_Glu => 13;
use constant Aminoacid_Gly => 14;
use constant Aminoacid_H => 15;
use constant Aminoacid_His => 16;
use constant Aminoacid_I => 17;
use constant Aminoacid_Ile => 18;
use constant Aminoacid_K => 19;
use constant Aminoacid_L => 20;
use constant Aminoacid_Leu => 21;
use constant Aminoacid_Lys => 22;
use constant Aminoacid_M => 23;
use constant Aminoacid_Met => 24;
use constant Aminoacid_N => 25;
use constant Aminoacid_P => 26;
use constant Aminoacid_Phe => 27;
use constant Aminoacid_Pro => 28;
use constant Aminoacid_Q => 29;
use constant Aminoacid_R => 30;
use constant Aminoacid_S => 31;
use constant Aminoacid_Ser => 32;
use constant Aminoacid_Stop => 33;
use constant Aminoacid_T => 34;
use constant Aminoacid_Thr => 35;
use constant Aminoacid_Trp => 36;
use constant Aminoacid_Tyr => 37;
use constant Aminoacid_V => 38;
use constant Aminoacid_Val => 39;
use constant Aminoacid_W => 40;
use constant Aminoacid_X => 41;
use constant Aminoacid_Y => 42;
use constant Aminoacid_a => 43;
use constant Aminoacid_c => 44;
use constant Aminoacid_d => 45;
use constant Aminoacid_e => 46;
use constant Aminoacid_f => 47;
use constant Aminoacid_g => 48;
use constant Aminoacid_h => 49;
use constant Aminoacid_i => 50;
use constant Aminoacid_k => 51;
use constant Aminoacid_l => 52;
use constant Aminoacid_m => 53;
use constant Aminoacid_n => 54;
use constant Aminoacid_p => 55;
use constant Aminoacid_q => 56;
use constant Aminoacid_r => 57;
use constant Aminoacid_s => 58;
use constant Aminoacid_t => 59;
use constant Aminoacid_v => 60;
use constant Aminoacid_w => 61;
use constant Aminoacid_x => 62;
use constant Aminoacid_y => 63;
package vdjserver::Nucleotide_ambiguous;
use constant Nucleotide_ambiguous_B => 0;
use constant Nucleotide_ambiguous_D => 1;
use constant Nucleotide_ambiguous_H => 2;
use constant Nucleotide_ambiguous_K => 3;
use constant Nucleotide_ambiguous_M => 4;
use constant Nucleotide_ambiguous_N => 5;
use constant Nucleotide_ambiguous_R => 6;
use constant Nucleotide_ambiguous_S => 7;
use constant Nucleotide_ambiguous_V => 8;
use constant Nucleotide_ambiguous_W => 9;
use constant Nucleotide_ambiguous_Y => 10;
use constant Nucleotide_ambiguous_b => 11;
use constant Nucleotide_ambiguous_d => 12;
use constant Nucleotide_ambiguous_h => 13;
use constant Nucleotide_ambiguous_k => 14;
use constant Nucleotide_ambiguous_m => 15;
use constant Nucleotide_ambiguous_n => 16;
use constant Nucleotide_ambiguous_r => 17;
use constant Nucleotide_ambiguous_s => 18;
use constant Nucleotide_ambiguous_v => 19;
use constant Nucleotide_ambiguous_w => 20;
use constant Nucleotide_ambiguous_y => 21;
package vdjserver::Nucleotide_defined;
use constant Nucleotide_defined_A => 0;
use constant Nucleotide_defined_C => 1;
use constant Nucleotide_defined_G => 2;
use constant Nucleotide_defined_T => 3;
use constant Nucleotide_defined_U => 4;
use constant Nucleotide_defined_a => 5;
use constant Nucleotide_defined_c => 6;
use constant Nucleotide_defined_g => 7;
use constant Nucleotide_defined_t => 8;
use constant Nucleotide_defined_u => 9;
package vdjserver::Segment_type;
use constant Segment_type_D => 0;
use constant Segment_type_J => 1;
use constant Segment_type_V => 2;
package vdjserver::UnspecifiedType;
use base qw(Class::Accessor);
vdjserver::UnspecifiedType->mk_accessors( qw( baseObjectType object ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{baseObjectType} = undef;
  $self->{object} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{baseObjectType}) {
      $self->{baseObjectType} = $vals->{baseObjectType};
    }
    if (defined $vals->{object}) {
      $self->{object} = $vals->{object};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'UnspecifiedType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{baseObjectType});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{object});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('UnspecifiedType');
  if (defined $self->{baseObjectType}) {
    $xfer += $output->writeFieldBegin('baseObjectType', TType::STRING, 1);
    $xfer += $output->writeString($self->{baseObjectType});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{object}) {
    $xfer += $output->writeFieldBegin('object', TType::STRING, 2);
    $xfer += $output->writeString($self->{object});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::aa_substitutionType;
use base qw(Class::Accessor);
vdjserver::aa_substitutionType->mk_accessors( qw( gl_aa read_aa read_pos0 ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{gl_aa} = undef;
  $self->{read_aa} = undef;
  $self->{read_pos0} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{gl_aa}) {
      $self->{gl_aa} = $vals->{gl_aa};
    }
    if (defined $vals->{read_aa}) {
      $self->{read_aa} = $vals->{read_aa};
    }
    if (defined $vals->{read_pos0}) {
      $self->{read_pos0} = $vals->{read_pos0};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'aa_substitutionType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{gl_aa});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{read_aa});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{read_pos0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('aa_substitutionType');
  if (defined $self->{gl_aa}) {
    $xfer += $output->writeFieldBegin('gl_aa', TType::I32, 1);
    $xfer += $output->writeI32($self->{gl_aa});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_aa}) {
    $xfer += $output->writeFieldBegin('read_aa', TType::I32, 2);
    $xfer += $output->writeI32($self->{read_aa});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_pos0}) {
    $xfer += $output->writeFieldBegin('read_pos0', TType::I64, 3);
    $xfer += $output->writeI64($self->{read_pos0});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::alignerType;
use base qw(Class::Accessor);
vdjserver::alignerType->mk_accessors( qw( aligner_id name parameters run_id uri version ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{aligner_id} = undef;
  $self->{name} = undef;
  $self->{parameters} = undef;
  $self->{run_id} = undef;
  $self->{uri} = undef;
  $self->{version} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{aligner_id}) {
      $self->{aligner_id} = $vals->{aligner_id};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{parameters}) {
      $self->{parameters} = $vals->{parameters};
    }
    if (defined $vals->{run_id}) {
      $self->{run_id} = $vals->{run_id};
    }
    if (defined $vals->{uri}) {
      $self->{uri} = $vals->{uri};
    }
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'alignerType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{aligner_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{parameters});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{run_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{uri} = new vdjserver::UnspecifiedType();
        $xfer += $self->{uri}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('alignerType');
  if (defined $self->{aligner_id}) {
    $xfer += $output->writeFieldBegin('aligner_id', TType::I64, 1);
    $xfer += $output->writeI64($self->{aligner_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{parameters}) {
    $xfer += $output->writeFieldBegin('parameters', TType::STRING, 3);
    $xfer += $output->writeString($self->{parameters});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{run_id}) {
    $xfer += $output->writeFieldBegin('run_id', TType::I64, 4);
    $xfer += $output->writeI64($self->{run_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uri}) {
    $xfer += $output->writeFieldBegin('uri', TType::STRUCT, 5);
    $xfer += $self->{uri}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::STRING, 6);
    $xfer += $output->writeString($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::generatorType;
use base qw(Class::Accessor);
vdjserver::generatorType->mk_accessors( qw( name time_gmt version ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{name} = undef;
  $self->{time_gmt} = undef;
  $self->{version} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{time_gmt}) {
      $self->{time_gmt} = $vals->{time_gmt};
    }
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'generatorType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{time_gmt});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('generatorType');
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 1);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{time_gmt}) {
    $xfer += $output->writeFieldBegin('time_gmt', TType::I64, 2);
    $xfer += $output->writeI64($self->{time_gmt});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::STRING, 3);
    $xfer += $output->writeString($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::germline_dbType;
use base qw(Class::Accessor);
vdjserver::germline_dbType->mk_accessors( qw( gl_db_id name species uri version ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{gl_db_id} = undef;
  $self->{name} = undef;
  $self->{species} = undef;
  $self->{uri} = undef;
  $self->{version} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{gl_db_id}) {
      $self->{gl_db_id} = $vals->{gl_db_id};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{species}) {
      $self->{species} = $vals->{species};
    }
    if (defined $vals->{uri}) {
      $self->{uri} = $vals->{uri};
    }
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'germline_dbType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{gl_db_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{species});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{uri} = new vdjserver::UnspecifiedType();
        $xfer += $self->{uri}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('germline_dbType');
  if (defined $self->{gl_db_id}) {
    $xfer += $output->writeFieldBegin('gl_db_id', TType::I64, 1);
    $xfer += $output->writeI64($self->{gl_db_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 2);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{species}) {
    $xfer += $output->writeFieldBegin('species', TType::STRING, 3);
    $xfer += $output->writeString($self->{species});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{uri}) {
    $xfer += $output->writeFieldBegin('uri', TType::STRUCT, 4);
    $xfer += $self->{uri}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::STRING, 5);
    $xfer += $output->writeString($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::gl_seg_matchType;
use base qw(Class::Accessor);
vdjserver::gl_seg_matchType->mk_accessors( qw( aligner_id gl_db_id gl_pos0 gl_seg_match_id name num_system type ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{aligner_id} = undef;
  $self->{gl_db_id} = undef;
  $self->{gl_pos0} = undef;
  $self->{gl_seg_match_id} = undef;
  $self->{name} = undef;
  $self->{num_system} = undef;
  $self->{type} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{aligner_id}) {
      $self->{aligner_id} = $vals->{aligner_id};
    }
    if (defined $vals->{gl_db_id}) {
      $self->{gl_db_id} = $vals->{gl_db_id};
    }
    if (defined $vals->{gl_pos0}) {
      $self->{gl_pos0} = $vals->{gl_pos0};
    }
    if (defined $vals->{gl_seg_match_id}) {
      $self->{gl_seg_match_id} = $vals->{gl_seg_match_id};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{num_system}) {
      $self->{num_system} = $vals->{num_system};
    }
    if (defined $vals->{type}) {
      $self->{type} = $vals->{type};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'gl_seg_matchType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{aligner_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{gl_db_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{gl_pos0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{gl_seg_match_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{num_system});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I32) {
        $xfer += $input->readI32(\$self->{type});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('gl_seg_matchType');
  if (defined $self->{aligner_id}) {
    $xfer += $output->writeFieldBegin('aligner_id', TType::I64, 1);
    $xfer += $output->writeI64($self->{aligner_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gl_db_id}) {
    $xfer += $output->writeFieldBegin('gl_db_id', TType::I64, 2);
    $xfer += $output->writeI64($self->{gl_db_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gl_pos0}) {
    $xfer += $output->writeFieldBegin('gl_pos0', TType::I64, 3);
    $xfer += $output->writeI64($self->{gl_pos0});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gl_seg_match_id}) {
    $xfer += $output->writeFieldBegin('gl_seg_match_id', TType::I64, 4);
    $xfer += $output->writeI64($self->{gl_seg_match_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 5);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{num_system}) {
    $xfer += $output->writeFieldBegin('num_system', TType::STRING, 6);
    $xfer += $output->writeString($self->{num_system});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{type}) {
    $xfer += $output->writeFieldBegin('type', TType::I32, 7);
    $xfer += $output->writeI32($self->{type});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::metaType;
use base qw(Class::Accessor);
vdjserver::metaType->mk_accessors( qw( aligner generator germline_db ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{aligner} = undef;
  $self->{generator} = undef;
  $self->{germline_db} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{aligner}) {
      $self->{aligner} = $vals->{aligner};
    }
    if (defined $vals->{generator}) {
      $self->{generator} = $vals->{generator};
    }
    if (defined $vals->{germline_db}) {
      $self->{germline_db} = $vals->{germline_db};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'metaType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{aligner} = new vdjserver::alignerType();
        $xfer += $self->{aligner}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{generator} = new vdjserver::generatorType();
        $xfer += $self->{generator}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{germline_db} = new vdjserver::germline_dbType();
        $xfer += $self->{germline_db}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('metaType');
  if (defined $self->{aligner}) {
    $xfer += $output->writeFieldBegin('aligner', TType::STRUCT, 1);
    $xfer += $self->{aligner}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{generator}) {
    $xfer += $output->writeFieldBegin('generator', TType::STRUCT, 2);
    $xfer += $self->{generator}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{germline_db}) {
    $xfer += $output->writeFieldBegin('germline_db', TType::STRUCT, 3);
    $xfer += $self->{germline_db}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::regionType;
use base qw(Class::Accessor);
vdjserver::regionType->mk_accessors( qw( aligner_id deletions identity insertions inverted mutated_invariant name num_system out_frame_indel out_frame_vdj read_len read_pos0 score stop_codon substitutions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{aligner_id} = undef;
  $self->{deletions} = undef;
  $self->{identity} = undef;
  $self->{insertions} = undef;
  $self->{inverted} = undef;
  $self->{mutated_invariant} = undef;
  $self->{name} = undef;
  $self->{num_system} = undef;
  $self->{out_frame_indel} = undef;
  $self->{out_frame_vdj} = undef;
  $self->{read_len} = undef;
  $self->{read_pos0} = undef;
  $self->{score} = undef;
  $self->{stop_codon} = undef;
  $self->{substitutions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{aligner_id}) {
      $self->{aligner_id} = $vals->{aligner_id};
    }
    if (defined $vals->{deletions}) {
      $self->{deletions} = $vals->{deletions};
    }
    if (defined $vals->{identity}) {
      $self->{identity} = $vals->{identity};
    }
    if (defined $vals->{insertions}) {
      $self->{insertions} = $vals->{insertions};
    }
    if (defined $vals->{inverted}) {
      $self->{inverted} = $vals->{inverted};
    }
    if (defined $vals->{mutated_invariant}) {
      $self->{mutated_invariant} = $vals->{mutated_invariant};
    }
    if (defined $vals->{name}) {
      $self->{name} = $vals->{name};
    }
    if (defined $vals->{num_system}) {
      $self->{num_system} = $vals->{num_system};
    }
    if (defined $vals->{out_frame_indel}) {
      $self->{out_frame_indel} = $vals->{out_frame_indel};
    }
    if (defined $vals->{out_frame_vdj}) {
      $self->{out_frame_vdj} = $vals->{out_frame_vdj};
    }
    if (defined $vals->{read_len}) {
      $self->{read_len} = $vals->{read_len};
    }
    if (defined $vals->{read_pos0}) {
      $self->{read_pos0} = $vals->{read_pos0};
    }
    if (defined $vals->{score}) {
      $self->{score} = $vals->{score};
    }
    if (defined $vals->{stop_codon}) {
      $self->{stop_codon} = $vals->{stop_codon};
    }
    if (defined $vals->{substitutions}) {
      $self->{substitutions} = $vals->{substitutions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'regionType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{aligner_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{deletions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{identity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{insertions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{inverted});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{mutated_invariant});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{name});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{num_system});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{out_frame_indel});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{out_frame_vdj});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{read_len});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{read_pos0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{score});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{stop_codon});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{substitutions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('regionType');
  if (defined $self->{aligner_id}) {
    $xfer += $output->writeFieldBegin('aligner_id', TType::I64, 1);
    $xfer += $output->writeI64($self->{aligner_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deletions}) {
    $xfer += $output->writeFieldBegin('deletions', TType::I64, 2);
    $xfer += $output->writeI64($self->{deletions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{identity}) {
    $xfer += $output->writeFieldBegin('identity', TType::STRING, 3);
    $xfer += $output->writeString($self->{identity});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{insertions}) {
    $xfer += $output->writeFieldBegin('insertions', TType::I64, 4);
    $xfer += $output->writeI64($self->{insertions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{inverted}) {
    $xfer += $output->writeFieldBegin('inverted', TType::BOOL, 5);
    $xfer += $output->writeBool($self->{inverted});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutated_invariant}) {
    $xfer += $output->writeFieldBegin('mutated_invariant', TType::BOOL, 6);
    $xfer += $output->writeBool($self->{mutated_invariant});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{name}) {
    $xfer += $output->writeFieldBegin('name', TType::STRING, 7);
    $xfer += $output->writeString($self->{name});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{num_system}) {
    $xfer += $output->writeFieldBegin('num_system', TType::STRING, 8);
    $xfer += $output->writeString($self->{num_system});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{out_frame_indel}) {
    $xfer += $output->writeFieldBegin('out_frame_indel', TType::BOOL, 9);
    $xfer += $output->writeBool($self->{out_frame_indel});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{out_frame_vdj}) {
    $xfer += $output->writeFieldBegin('out_frame_vdj', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{out_frame_vdj});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_len}) {
    $xfer += $output->writeFieldBegin('read_len', TType::I64, 11);
    $xfer += $output->writeI64($self->{read_len});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_pos0}) {
    $xfer += $output->writeFieldBegin('read_pos0', TType::I64, 12);
    $xfer += $output->writeI64($self->{read_pos0});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{score}) {
    $xfer += $output->writeFieldBegin('score', TType::I64, 13);
    $xfer += $output->writeI64($self->{score});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stop_codon}) {
    $xfer += $output->writeFieldBegin('stop_codon', TType::BOOL, 14);
    $xfer += $output->writeBool($self->{stop_codon});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{substitutions}) {
    $xfer += $output->writeFieldBegin('substitutions', TType::I64, 15);
    $xfer += $output->writeI64($self->{substitutions});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::segment_matchType;
use base qw(Class::Accessor);
vdjserver::segment_matchType->mk_accessors( qw( aa_substitution btop deletions gl_len gl_seg_match identity insertions inverted mutated_invariant out_frame_indel out_frame_vdj read_len read_pos0 score segment_match_id stop_codon substitutions ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{aa_substitution} = undef;
  $self->{btop} = undef;
  $self->{deletions} = undef;
  $self->{gl_len} = undef;
  $self->{gl_seg_match} = undef;
  $self->{identity} = undef;
  $self->{insertions} = undef;
  $self->{inverted} = undef;
  $self->{mutated_invariant} = undef;
  $self->{out_frame_indel} = undef;
  $self->{out_frame_vdj} = undef;
  $self->{read_len} = undef;
  $self->{read_pos0} = undef;
  $self->{score} = undef;
  $self->{segment_match_id} = undef;
  $self->{stop_codon} = undef;
  $self->{substitutions} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{aa_substitution}) {
      $self->{aa_substitution} = $vals->{aa_substitution};
    }
    if (defined $vals->{btop}) {
      $self->{btop} = $vals->{btop};
    }
    if (defined $vals->{deletions}) {
      $self->{deletions} = $vals->{deletions};
    }
    if (defined $vals->{gl_len}) {
      $self->{gl_len} = $vals->{gl_len};
    }
    if (defined $vals->{gl_seg_match}) {
      $self->{gl_seg_match} = $vals->{gl_seg_match};
    }
    if (defined $vals->{identity}) {
      $self->{identity} = $vals->{identity};
    }
    if (defined $vals->{insertions}) {
      $self->{insertions} = $vals->{insertions};
    }
    if (defined $vals->{inverted}) {
      $self->{inverted} = $vals->{inverted};
    }
    if (defined $vals->{mutated_invariant}) {
      $self->{mutated_invariant} = $vals->{mutated_invariant};
    }
    if (defined $vals->{out_frame_indel}) {
      $self->{out_frame_indel} = $vals->{out_frame_indel};
    }
    if (defined $vals->{out_frame_vdj}) {
      $self->{out_frame_vdj} = $vals->{out_frame_vdj};
    }
    if (defined $vals->{read_len}) {
      $self->{read_len} = $vals->{read_len};
    }
    if (defined $vals->{read_pos0}) {
      $self->{read_pos0} = $vals->{read_pos0};
    }
    if (defined $vals->{score}) {
      $self->{score} = $vals->{score};
    }
    if (defined $vals->{segment_match_id}) {
      $self->{segment_match_id} = $vals->{segment_match_id};
    }
    if (defined $vals->{stop_codon}) {
      $self->{stop_codon} = $vals->{stop_codon};
    }
    if (defined $vals->{substitutions}) {
      $self->{substitutions} = $vals->{substitutions};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'segment_matchType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size0 = 0;
          $self->{aa_substitution} = [];
          my $_etype3 = 0;
          $xfer += $input->readListBegin(\$_etype3, \$_size0);
          for (my $_i4 = 0; $_i4 < $_size0; ++$_i4)
          {
            my $elem5 = undef;
            $elem5 = new vdjserver::aa_substitutionType();
            $xfer += $elem5->read($input);
            push(@{$self->{aa_substitution}},$elem5);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{btop});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{deletions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^4$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{gl_len});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^5$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size6 = 0;
          $self->{gl_seg_match} = [];
          my $_etype9 = 0;
          $xfer += $input->readListBegin(\$_etype9, \$_size6);
          for (my $_i10 = 0; $_i10 < $_size6; ++$_i10)
          {
            my $elem11 = undef;
            $elem11 = new vdjserver::gl_seg_matchType();
            $xfer += $elem11->read($input);
            push(@{$self->{gl_seg_match}},$elem11);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^6$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{identity});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^7$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{insertions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^8$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{inverted});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^9$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{mutated_invariant});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^10$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{out_frame_indel});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^11$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{out_frame_vdj});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^12$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{read_len});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^13$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{read_pos0});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^14$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{score});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^15$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{segment_match_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^16$/ && do{      if ($ftype == TType::BOOL) {
        $xfer += $input->readBool(\$self->{stop_codon});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^17$/ && do{      if ($ftype == TType::I64) {
        $xfer += $input->readI64(\$self->{substitutions});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('segment_matchType');
  if (defined $self->{aa_substitution}) {
    $xfer += $output->writeFieldBegin('aa_substitution', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{aa_substitution}}));
      {
        foreach my $iter12 (@{$self->{aa_substitution}}) 
        {
          $xfer += ${iter12}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{btop}) {
    $xfer += $output->writeFieldBegin('btop', TType::STRING, 2);
    $xfer += $output->writeString($self->{btop});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{deletions}) {
    $xfer += $output->writeFieldBegin('deletions', TType::I64, 3);
    $xfer += $output->writeI64($self->{deletions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gl_len}) {
    $xfer += $output->writeFieldBegin('gl_len', TType::I64, 4);
    $xfer += $output->writeI64($self->{gl_len});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{gl_seg_match}) {
    $xfer += $output->writeFieldBegin('gl_seg_match', TType::LIST, 5);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{gl_seg_match}}));
      {
        foreach my $iter13 (@{$self->{gl_seg_match}}) 
        {
          $xfer += ${iter13}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{identity}) {
    $xfer += $output->writeFieldBegin('identity', TType::STRING, 6);
    $xfer += $output->writeString($self->{identity});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{insertions}) {
    $xfer += $output->writeFieldBegin('insertions', TType::I64, 7);
    $xfer += $output->writeI64($self->{insertions});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{inverted}) {
    $xfer += $output->writeFieldBegin('inverted', TType::BOOL, 8);
    $xfer += $output->writeBool($self->{inverted});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{mutated_invariant}) {
    $xfer += $output->writeFieldBegin('mutated_invariant', TType::BOOL, 9);
    $xfer += $output->writeBool($self->{mutated_invariant});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{out_frame_indel}) {
    $xfer += $output->writeFieldBegin('out_frame_indel', TType::BOOL, 10);
    $xfer += $output->writeBool($self->{out_frame_indel});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{out_frame_vdj}) {
    $xfer += $output->writeFieldBegin('out_frame_vdj', TType::BOOL, 11);
    $xfer += $output->writeBool($self->{out_frame_vdj});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_len}) {
    $xfer += $output->writeFieldBegin('read_len', TType::I64, 12);
    $xfer += $output->writeI64($self->{read_len});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_pos0}) {
    $xfer += $output->writeFieldBegin('read_pos0', TType::I64, 13);
    $xfer += $output->writeI64($self->{read_pos0});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{score}) {
    $xfer += $output->writeFieldBegin('score', TType::I64, 14);
    $xfer += $output->writeI64($self->{score});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{segment_match_id}) {
    $xfer += $output->writeFieldBegin('segment_match_id', TType::I64, 15);
    $xfer += $output->writeI64($self->{segment_match_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{stop_codon}) {
    $xfer += $output->writeFieldBegin('stop_codon', TType::BOOL, 16);
    $xfer += $output->writeBool($self->{stop_codon});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{substitutions}) {
    $xfer += $output->writeFieldBegin('substitutions', TType::I64, 17);
    $xfer += $output->writeI64($self->{substitutions});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::combinationType;
use base qw(Class::Accessor);
vdjserver::combinationType->mk_accessors( qw( region segments ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{region} = undef;
  $self->{segments} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{region}) {
      $self->{region} = $vals->{region};
    }
    if (defined $vals->{segments}) {
      $self->{segments} = $vals->{segments};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'combinationType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size14 = 0;
          $self->{region} = [];
          my $_etype17 = 0;
          $xfer += $input->readListBegin(\$_etype17, \$_size14);
          for (my $_i18 = 0; $_i18 < $_size14; ++$_i18)
          {
            my $elem19 = undef;
            $elem19 = new vdjserver::regionType();
            $xfer += $elem19->read($input);
            push(@{$self->{region}},$elem19);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size20 = 0;
          $self->{segments} = [];
          my $_etype23 = 0;
          $xfer += $input->readListBegin(\$_etype23, \$_size20);
          for (my $_i24 = 0; $_i24 < $_size20; ++$_i24)
          {
            my $elem25 = undef;
            $xfer += $input->readI64(\$elem25);
            push(@{$self->{segments}},$elem25);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('combinationType');
  if (defined $self->{region}) {
    $xfer += $output->writeFieldBegin('region', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{region}}));
      {
        foreach my $iter26 (@{$self->{region}}) 
        {
          $xfer += ${iter26}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{segments}) {
    $xfer += $output->writeFieldBegin('segments', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::I64, scalar(@{$self->{segments}}));
      {
        foreach my $iter27 (@{$self->{segments}}) 
        {
          $xfer += $output->writeI64($iter27);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::vdj_alignmentType;
use base qw(Class::Accessor);
vdjserver::vdj_alignmentType->mk_accessors( qw( combination segment_match ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{combination} = undef;
  $self->{segment_match} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{combination}) {
      $self->{combination} = $vals->{combination};
    }
    if (defined $vals->{segment_match}) {
      $self->{segment_match} = $vals->{segment_match};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'vdj_alignmentType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size28 = 0;
          $self->{combination} = [];
          my $_etype31 = 0;
          $xfer += $input->readListBegin(\$_etype31, \$_size28);
          for (my $_i32 = 0; $_i32 < $_size28; ++$_i32)
          {
            my $elem33 = undef;
            $elem33 = new vdjserver::combinationType();
            $xfer += $elem33->read($input);
            push(@{$self->{combination}},$elem33);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::LIST) {
        {
          my $_size34 = 0;
          $self->{segment_match} = [];
          my $_etype37 = 0;
          $xfer += $input->readListBegin(\$_etype37, \$_size34);
          for (my $_i38 = 0; $_i38 < $_size34; ++$_i38)
          {
            my $elem39 = undef;
            $elem39 = new vdjserver::segment_matchType();
            $xfer += $elem39->read($input);
            push(@{$self->{segment_match}},$elem39);
          }
          $xfer += $input->readListEnd();
        }
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('vdj_alignmentType');
  if (defined $self->{combination}) {
    $xfer += $output->writeFieldBegin('combination', TType::LIST, 1);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{combination}}));
      {
        foreach my $iter40 (@{$self->{combination}}) 
        {
          $xfer += ${iter40}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{segment_match}) {
    $xfer += $output->writeFieldBegin('segment_match', TType::LIST, 2);
    {
      $xfer += $output->writeListBegin(TType::STRUCT, scalar(@{$self->{segment_match}}));
      {
        foreach my $iter41 (@{$self->{segment_match}}) 
        {
          $xfer += ${iter41}->write($output);
        }
      }
      $xfer += $output->writeListEnd();
    }
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::readType;
use base qw(Class::Accessor);
vdjserver::readType->mk_accessors( qw( read_id vdj_alignment ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{read_id} = undef;
  $self->{vdj_alignment} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{read_id}) {
      $self->{read_id} = $vals->{read_id};
    }
    if (defined $vals->{vdj_alignment}) {
      $self->{vdj_alignment} = $vals->{vdj_alignment};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'readType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRING) {
        $xfer += $input->readString(\$self->{read_id});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{vdj_alignment} = new vdjserver::vdj_alignmentType();
        $xfer += $self->{vdj_alignment}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('readType');
  if (defined $self->{read_id}) {
    $xfer += $output->writeFieldBegin('read_id', TType::STRING, 1);
    $xfer += $output->writeString($self->{read_id});
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{vdj_alignment}) {
    $xfer += $output->writeFieldBegin('vdj_alignment', TType::STRUCT, 2);
    $xfer += $self->{vdj_alignment}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::read_resultsType;
use base qw(Class::Accessor);
vdjserver::read_resultsType->mk_accessors( qw( read ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{read} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{read}) {
      $self->{read} = $vals->{read};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'read_resultsType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{read} = new vdjserver::readType();
        $xfer += $self->{read}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('read_resultsType');
  if (defined $self->{read}) {
    $xfer += $output->writeFieldBegin('read', TType::STRUCT, 1);
    $xfer += $self->{read}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

package vdjserver::vdjmlType;
use base qw(Class::Accessor);
vdjserver::vdjmlType->mk_accessors( qw( meta read_results version ) );

sub new {
  my $classname = shift;
  my $self      = {};
  my $vals      = shift || {};
  $self->{meta} = undef;
  $self->{read_results} = undef;
  $self->{version} = undef;
  if (UNIVERSAL::isa($vals,'HASH')) {
    if (defined $vals->{meta}) {
      $self->{meta} = $vals->{meta};
    }
    if (defined $vals->{read_results}) {
      $self->{read_results} = $vals->{read_results};
    }
    if (defined $vals->{version}) {
      $self->{version} = $vals->{version};
    }
  }
  return bless ($self, $classname);
}

sub getName {
  return 'vdjmlType';
}

sub read {
  my ($self, $input) = @_;
  my $xfer  = 0;
  my $fname;
  my $ftype = 0;
  my $fid   = 0;
  $xfer += $input->readStructBegin(\$fname);
  while (1) 
  {
    $xfer += $input->readFieldBegin(\$fname, \$ftype, \$fid);
    if ($ftype == TType::STOP) {
      last;
    }
    SWITCH: for($fid)
    {
      /^1$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{meta} = new vdjserver::metaType();
        $xfer += $self->{meta}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^2$/ && do{      if ($ftype == TType::STRUCT) {
        $self->{read_results} = new vdjserver::read_resultsType();
        $xfer += $self->{read_results}->read($input);
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
      /^3$/ && do{      if ($ftype == TType::DOUBLE) {
        $xfer += $input->readDouble(\$self->{version});
      } else {
        $xfer += $input->skip($ftype);
      }
      last; };
        $xfer += $input->skip($ftype);
    }
    $xfer += $input->readFieldEnd();
  }
  $xfer += $input->readStructEnd();
  return $xfer;
}

sub write {
  my ($self, $output) = @_;
  my $xfer   = 0;
  $xfer += $output->writeStructBegin('vdjmlType');
  if (defined $self->{meta}) {
    $xfer += $output->writeFieldBegin('meta', TType::STRUCT, 1);
    $xfer += $self->{meta}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{read_results}) {
    $xfer += $output->writeFieldBegin('read_results', TType::STRUCT, 2);
    $xfer += $self->{read_results}->write($output);
    $xfer += $output->writeFieldEnd();
  }
  if (defined $self->{version}) {
    $xfer += $output->writeFieldBegin('version', TType::DOUBLE, 3);
    $xfer += $output->writeDouble($self->{version});
    $xfer += $output->writeFieldEnd();
  }
  $xfer += $output->writeFieldStop();
  $xfer += $output->writeStructEnd();
  return $xfer;
}

1;
