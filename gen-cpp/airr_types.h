/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef airr_TYPES_H
#define airr_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace airr {

struct Origin {
  enum type {
    HUMAN = 0,
    ANIMAL = 1,
    SYNTHETIC = 2
  };
};

extern const std::map<int, const char*> _Origin_VALUES_TO_NAMES;

struct Sex {
  enum type {
    MALE = 0,
    FEMALE = 1
  };
};

extern const std::map<int, const char*> _Sex_VALUES_TO_NAMES;

struct Locus {
  enum type {
    IGH = 0,
    IGK = 1,
    IGL = 2,
    TRB = 3,
    TRA = 4,
    TRG = 5,
    TRD = 6
  };
};

extern const std::map<int, const char*> _Locus_VALUES_TO_NAMES;

class Study;

class Subject;

class Sample;

class Chain;

class FindCdr3Req;

class FindCdr3Resp;

typedef struct _Study__isset {
  _Study__isset() : id(false), title(false), labName(false), correspondence(false), doi(false) {}
  bool id :1;
  bool title :1;
  bool labName :1;
  bool correspondence :1;
  bool doi :1;
} _Study__isset;

class Study {
 public:

  Study(const Study&);
  Study& operator=(const Study&);
  Study() : id(), title(), labName(), correspondence(), doi() {
  }

  virtual ~Study() throw();
  std::string id;
  std::string title;
  std::string labName;
  std::string correspondence;
  std::string doi;

  _Study__isset __isset;

  void __set_id(const std::string& val);

  void __set_title(const std::string& val);

  void __set_labName(const std::string& val);

  void __set_correspondence(const std::string& val);

  void __set_doi(const std::string& val);

  bool operator == (const Study & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.title != rhs.__isset.title)
      return false;
    else if (__isset.title && !(title == rhs.title))
      return false;
    if (__isset.labName != rhs.__isset.labName)
      return false;
    else if (__isset.labName && !(labName == rhs.labName))
      return false;
    if (__isset.correspondence != rhs.__isset.correspondence)
      return false;
    else if (__isset.correspondence && !(correspondence == rhs.correspondence))
      return false;
    if (__isset.doi != rhs.__isset.doi)
      return false;
    else if (__isset.doi && !(doi == rhs.doi))
      return false;
    return true;
  }
  bool operator != (const Study &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Study & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Study &a, Study &b);

inline std::ostream& operator<<(std::ostream& out, const Study& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Subject__isset {
  _Subject__isset() : id(false), origin(false), sex(false), age(false) {}
  bool id :1;
  bool origin :1;
  bool sex :1;
  bool age :1;
} _Subject__isset;

class Subject {
 public:

  Subject(const Subject&);
  Subject& operator=(const Subject&);
  Subject() : id(), origin((Origin::type)0), sex((Sex::type)0), age(0) {
  }

  virtual ~Subject() throw();
  std::string id;
  Origin::type origin;
  Sex::type sex;
  int32_t age;

  _Subject__isset __isset;

  void __set_id(const std::string& val);

  void __set_origin(const Origin::type val);

  void __set_sex(const Sex::type val);

  void __set_age(const int32_t val);

  bool operator == (const Subject & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.origin != rhs.__isset.origin)
      return false;
    else if (__isset.origin && !(origin == rhs.origin))
      return false;
    if (__isset.sex != rhs.__isset.sex)
      return false;
    else if (__isset.sex && !(sex == rhs.sex))
      return false;
    if (__isset.age != rhs.__isset.age)
      return false;
    else if (__isset.age && !(age == rhs.age))
      return false;
    return true;
  }
  bool operator != (const Subject &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Subject & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Subject &a, Subject &b);

inline std::ostream& operator<<(std::ostream& out, const Subject& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Sample__isset {
  _Sample__isset() : id(false), type(false), source(false), dt(false) {}
  bool id :1;
  bool type :1;
  bool source :1;
  bool dt :1;
} _Sample__isset;

class Sample {
 public:

  Sample(const Sample&);
  Sample& operator=(const Sample&);
  Sample() : id(), type(), source(), dt() {
  }

  virtual ~Sample() throw();
  std::string id;
  std::string type;
  std::string source;
  std::string dt;

  _Sample__isset __isset;

  void __set_id(const std::string& val);

  void __set_type(const std::string& val);

  void __set_source(const std::string& val);

  void __set_dt(const std::string& val);

  bool operator == (const Sample & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.type != rhs.__isset.type)
      return false;
    else if (__isset.type && !(type == rhs.type))
      return false;
    if (__isset.source != rhs.__isset.source)
      return false;
    else if (__isset.source && !(source == rhs.source))
      return false;
    if (__isset.dt != rhs.__isset.dt)
      return false;
    else if (__isset.dt && !(dt == rhs.dt))
      return false;
    return true;
  }
  bool operator != (const Sample &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Sample & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Sample &a, Sample &b);

inline std::ostream& operator<<(std::ostream& out, const Sample& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _Chain__isset {
  _Chain__isset() : id(false), ntSeq(false), locus(false), vAllele(false), dAllele(false), jAllele(false), alignment(false), ntCDR3(false) {}
  bool id :1;
  bool ntSeq :1;
  bool locus :1;
  bool vAllele :1;
  bool dAllele :1;
  bool jAllele :1;
  bool alignment :1;
  bool ntCDR3 :1;
} _Chain__isset;

class Chain {
 public:

  Chain(const Chain&);
  Chain& operator=(const Chain&);
  Chain() : id(), ntSeq(), locus((Locus::type)0), vAllele(), dAllele(), jAllele(), alignment(), ntCDR3() {
  }

  virtual ~Chain() throw();
  std::string id;
  std::string ntSeq;
  Locus::type locus;
  std::string vAllele;
  std::string dAllele;
  std::string jAllele;
  std::string alignment;
  std::string ntCDR3;

  _Chain__isset __isset;

  void __set_id(const std::string& val);

  void __set_ntSeq(const std::string& val);

  void __set_locus(const Locus::type val);

  void __set_vAllele(const std::string& val);

  void __set_dAllele(const std::string& val);

  void __set_jAllele(const std::string& val);

  void __set_alignment(const std::string& val);

  void __set_ntCDR3(const std::string& val);

  bool operator == (const Chain & rhs) const
  {
    if (__isset.id != rhs.__isset.id)
      return false;
    else if (__isset.id && !(id == rhs.id))
      return false;
    if (__isset.ntSeq != rhs.__isset.ntSeq)
      return false;
    else if (__isset.ntSeq && !(ntSeq == rhs.ntSeq))
      return false;
    if (__isset.locus != rhs.__isset.locus)
      return false;
    else if (__isset.locus && !(locus == rhs.locus))
      return false;
    if (__isset.vAllele != rhs.__isset.vAllele)
      return false;
    else if (__isset.vAllele && !(vAllele == rhs.vAllele))
      return false;
    if (__isset.dAllele != rhs.__isset.dAllele)
      return false;
    else if (__isset.dAllele && !(dAllele == rhs.dAllele))
      return false;
    if (__isset.jAllele != rhs.__isset.jAllele)
      return false;
    else if (__isset.jAllele && !(jAllele == rhs.jAllele))
      return false;
    if (__isset.alignment != rhs.__isset.alignment)
      return false;
    else if (__isset.alignment && !(alignment == rhs.alignment))
      return false;
    if (__isset.ntCDR3 != rhs.__isset.ntCDR3)
      return false;
    else if (__isset.ntCDR3 && !(ntCDR3 == rhs.ntCDR3))
      return false;
    return true;
  }
  bool operator != (const Chain &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const Chain & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(Chain &a, Chain &b);

inline std::ostream& operator<<(std::ostream& out, const Chain& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FindCdr3Req__isset {
  _FindCdr3Req__isset() : studyIds(false) {}
  bool studyIds :1;
} _FindCdr3Req__isset;

class FindCdr3Req {
 public:

  FindCdr3Req(const FindCdr3Req&);
  FindCdr3Req& operator=(const FindCdr3Req&);
  FindCdr3Req() : cdr3(), locus((Locus::type)0) {
  }

  virtual ~FindCdr3Req() throw();
  std::string cdr3;
  Locus::type locus;
  std::vector<std::string>  studyIds;

  _FindCdr3Req__isset __isset;

  void __set_cdr3(const std::string& val);

  void __set_locus(const Locus::type val);

  void __set_studyIds(const std::vector<std::string> & val);

  bool operator == (const FindCdr3Req & rhs) const
  {
    if (!(cdr3 == rhs.cdr3))
      return false;
    if (!(locus == rhs.locus))
      return false;
    if (__isset.studyIds != rhs.__isset.studyIds)
      return false;
    else if (__isset.studyIds && !(studyIds == rhs.studyIds))
      return false;
    return true;
  }
  bool operator != (const FindCdr3Req &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FindCdr3Req & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FindCdr3Req &a, FindCdr3Req &b);

inline std::ostream& operator<<(std::ostream& out, const FindCdr3Req& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _FindCdr3Resp__isset {
  _FindCdr3Resp__isset() : specificities(false) {}
  bool specificities :1;
} _FindCdr3Resp__isset;

class FindCdr3Resp {
 public:

  FindCdr3Resp(const FindCdr3Resp&);
  FindCdr3Resp& operator=(const FindCdr3Resp&);
  FindCdr3Resp() : found(0) {
  }

  virtual ~FindCdr3Resp() throw();
  bool found;
  std::vector<std::string>  specificities;

  _FindCdr3Resp__isset __isset;

  void __set_found(const bool val);

  void __set_specificities(const std::vector<std::string> & val);

  bool operator == (const FindCdr3Resp & rhs) const
  {
    if (!(found == rhs.found))
      return false;
    if (__isset.specificities != rhs.__isset.specificities)
      return false;
    else if (__isset.specificities && !(specificities == rhs.specificities))
      return false;
    return true;
  }
  bool operator != (const FindCdr3Resp &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const FindCdr3Resp & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(FindCdr3Resp &a, FindCdr3Resp &b);

inline std::ostream& operator<<(std::ostream& out, const FindCdr3Resp& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
