/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#ifndef vdjml_TYPES_H
#define vdjml_TYPES_H

#include <iosfwd>

#include <thrift/Thrift.h>
#include <thrift/TApplicationException.h>
#include <thrift/protocol/TProtocol.h>
#include <thrift/transport/TTransport.h>

#include <thrift/cxxfunctional.h>


namespace vdjserver {

struct Aminoacid {
  enum type {
    Aminoacid__ = 0,
    Aminoacid_A = 1,
    Aminoacid_Ala = 2,
    Aminoacid_Arg = 3,
    Aminoacid_Asn = 4,
    Aminoacid_Asp = 5,
    Aminoacid_C = 6,
    Aminoacid_Cys = 7,
    Aminoacid_D = 8,
    Aminoacid_E = 9,
    Aminoacid_F = 10,
    Aminoacid_G = 11,
    Aminoacid_Gln = 12,
    Aminoacid_Glu = 13,
    Aminoacid_Gly = 14,
    Aminoacid_H = 15,
    Aminoacid_His = 16,
    Aminoacid_I = 17,
    Aminoacid_Ile = 18,
    Aminoacid_K = 19,
    Aminoacid_L = 20,
    Aminoacid_Leu = 21,
    Aminoacid_Lys = 22,
    Aminoacid_M = 23,
    Aminoacid_Met = 24,
    Aminoacid_N = 25,
    Aminoacid_P = 26,
    Aminoacid_Phe = 27,
    Aminoacid_Pro = 28,
    Aminoacid_Q = 29,
    Aminoacid_R = 30,
    Aminoacid_S = 31,
    Aminoacid_Ser = 32,
    Aminoacid_Stop = 33,
    Aminoacid_T = 34,
    Aminoacid_Thr = 35,
    Aminoacid_Trp = 36,
    Aminoacid_Tyr = 37,
    Aminoacid_V = 38,
    Aminoacid_Val = 39,
    Aminoacid_W = 40,
    Aminoacid_X = 41,
    Aminoacid_Y = 42,
    Aminoacid_a = 43,
    Aminoacid_c = 44,
    Aminoacid_d = 45,
    Aminoacid_e = 46,
    Aminoacid_f = 47,
    Aminoacid_g = 48,
    Aminoacid_h = 49,
    Aminoacid_i = 50,
    Aminoacid_k = 51,
    Aminoacid_l = 52,
    Aminoacid_m = 53,
    Aminoacid_n = 54,
    Aminoacid_p = 55,
    Aminoacid_q = 56,
    Aminoacid_r = 57,
    Aminoacid_s = 58,
    Aminoacid_t = 59,
    Aminoacid_v = 60,
    Aminoacid_w = 61,
    Aminoacid_x = 62,
    Aminoacid_y = 63
  };
};

extern const std::map<int, const char*> _Aminoacid_VALUES_TO_NAMES;

struct Nucleotide_ambiguous {
  enum type {
    Nucleotide_ambiguous_B = 0,
    Nucleotide_ambiguous_D = 1,
    Nucleotide_ambiguous_H = 2,
    Nucleotide_ambiguous_K = 3,
    Nucleotide_ambiguous_M = 4,
    Nucleotide_ambiguous_N = 5,
    Nucleotide_ambiguous_R = 6,
    Nucleotide_ambiguous_S = 7,
    Nucleotide_ambiguous_V = 8,
    Nucleotide_ambiguous_W = 9,
    Nucleotide_ambiguous_Y = 10,
    Nucleotide_ambiguous_b = 11,
    Nucleotide_ambiguous_d = 12,
    Nucleotide_ambiguous_h = 13,
    Nucleotide_ambiguous_k = 14,
    Nucleotide_ambiguous_m = 15,
    Nucleotide_ambiguous_n = 16,
    Nucleotide_ambiguous_r = 17,
    Nucleotide_ambiguous_s = 18,
    Nucleotide_ambiguous_v = 19,
    Nucleotide_ambiguous_w = 20,
    Nucleotide_ambiguous_y = 21
  };
};

extern const std::map<int, const char*> _Nucleotide_ambiguous_VALUES_TO_NAMES;

struct Nucleotide_defined {
  enum type {
    Nucleotide_defined_A = 0,
    Nucleotide_defined_C = 1,
    Nucleotide_defined_G = 2,
    Nucleotide_defined_T = 3,
    Nucleotide_defined_U = 4,
    Nucleotide_defined_a = 5,
    Nucleotide_defined_c = 6,
    Nucleotide_defined_g = 7,
    Nucleotide_defined_t = 8,
    Nucleotide_defined_u = 9
  };
};

extern const std::map<int, const char*> _Nucleotide_defined_VALUES_TO_NAMES;

struct Segment_type {
  enum type {
    Segment_type_D = 0,
    Segment_type_J = 1,
    Segment_type_V = 2
  };
};

extern const std::map<int, const char*> _Segment_type_VALUES_TO_NAMES;

class UnspecifiedType;

class aa_substitutionType;

class alignerType;

class generatorType;

class germline_dbType;

class gl_seg_matchType;

class metaType;

class regionType;

class segment_matchType;

class combinationType;

class vdj_alignmentType;

class readType;

class read_resultsType;

class vdjmlType;


class UnspecifiedType {
 public:

  UnspecifiedType(const UnspecifiedType&);
  UnspecifiedType& operator=(const UnspecifiedType&);
  UnspecifiedType() : baseObjectType(), object() {
  }

  virtual ~UnspecifiedType() throw();
  std::string baseObjectType;
  std::string object;

  void __set_baseObjectType(const std::string& val);

  void __set_object(const std::string& val);

  bool operator == (const UnspecifiedType & rhs) const
  {
    if (!(baseObjectType == rhs.baseObjectType))
      return false;
    if (!(object == rhs.object))
      return false;
    return true;
  }
  bool operator != (const UnspecifiedType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const UnspecifiedType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(UnspecifiedType &a, UnspecifiedType &b);

inline std::ostream& operator<<(std::ostream& out, const UnspecifiedType& obj)
{
  obj.printTo(out);
  return out;
}


class aa_substitutionType {
 public:

  aa_substitutionType(const aa_substitutionType&);
  aa_substitutionType& operator=(const aa_substitutionType&);
  aa_substitutionType() : gl_aa((Aminoacid::type)0), read_aa((Aminoacid::type)0), read_pos0(0) {
  }

  virtual ~aa_substitutionType() throw();
  Aminoacid::type gl_aa;
  Aminoacid::type read_aa;
  int64_t read_pos0;

  void __set_gl_aa(const Aminoacid::type val);

  void __set_read_aa(const Aminoacid::type val);

  void __set_read_pos0(const int64_t val);

  bool operator == (const aa_substitutionType & rhs) const
  {
    if (!(gl_aa == rhs.gl_aa))
      return false;
    if (!(read_aa == rhs.read_aa))
      return false;
    if (!(read_pos0 == rhs.read_pos0))
      return false;
    return true;
  }
  bool operator != (const aa_substitutionType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const aa_substitutionType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(aa_substitutionType &a, aa_substitutionType &b);

inline std::ostream& operator<<(std::ostream& out, const aa_substitutionType& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _alignerType__isset {
  _alignerType__isset() : parameters(false), run_id(false), uri(false), version(false) {}
  bool parameters :1;
  bool run_id :1;
  bool uri :1;
  bool version :1;
} _alignerType__isset;

class alignerType {
 public:

  alignerType(const alignerType&);
  alignerType& operator=(const alignerType&);
  alignerType() : aligner_id(0), name(), parameters(), run_id(0), version() {
  }

  virtual ~alignerType() throw();
  int64_t aligner_id;
  std::string name;
  std::string parameters;
  int64_t run_id;
  UnspecifiedType uri;
  std::string version;

  _alignerType__isset __isset;

  void __set_aligner_id(const int64_t val);

  void __set_name(const std::string& val);

  void __set_parameters(const std::string& val);

  void __set_run_id(const int64_t val);

  void __set_uri(const UnspecifiedType& val);

  void __set_version(const std::string& val);

  bool operator == (const alignerType & rhs) const
  {
    if (!(aligner_id == rhs.aligner_id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (__isset.parameters != rhs.__isset.parameters)
      return false;
    else if (__isset.parameters && !(parameters == rhs.parameters))
      return false;
    if (__isset.run_id != rhs.__isset.run_id)
      return false;
    else if (__isset.run_id && !(run_id == rhs.run_id))
      return false;
    if (__isset.uri != rhs.__isset.uri)
      return false;
    else if (__isset.uri && !(uri == rhs.uri))
      return false;
    if (__isset.version != rhs.__isset.version)
      return false;
    else if (__isset.version && !(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const alignerType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const alignerType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(alignerType &a, alignerType &b);

inline std::ostream& operator<<(std::ostream& out, const alignerType& obj)
{
  obj.printTo(out);
  return out;
}


class generatorType {
 public:

  generatorType(const generatorType&);
  generatorType& operator=(const generatorType&);
  generatorType() : name(), time_gmt(0), version() {
  }

  virtual ~generatorType() throw();
  std::string name;
  int64_t time_gmt;
  std::string version;

  void __set_name(const std::string& val);

  void __set_time_gmt(const int64_t val);

  void __set_version(const std::string& val);

  bool operator == (const generatorType & rhs) const
  {
    if (!(name == rhs.name))
      return false;
    if (!(time_gmt == rhs.time_gmt))
      return false;
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const generatorType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const generatorType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(generatorType &a, generatorType &b);

inline std::ostream& operator<<(std::ostream& out, const generatorType& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _germline_dbType__isset {
  _germline_dbType__isset() : uri(false) {}
  bool uri :1;
} _germline_dbType__isset;

class germline_dbType {
 public:

  germline_dbType(const germline_dbType&);
  germline_dbType& operator=(const germline_dbType&);
  germline_dbType() : gl_db_id(0), name(), species(), version() {
  }

  virtual ~germline_dbType() throw();
  int64_t gl_db_id;
  std::string name;
  std::string species;
  UnspecifiedType uri;
  std::string version;

  _germline_dbType__isset __isset;

  void __set_gl_db_id(const int64_t val);

  void __set_name(const std::string& val);

  void __set_species(const std::string& val);

  void __set_uri(const UnspecifiedType& val);

  void __set_version(const std::string& val);

  bool operator == (const germline_dbType & rhs) const
  {
    if (!(gl_db_id == rhs.gl_db_id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(species == rhs.species))
      return false;
    if (__isset.uri != rhs.__isset.uri)
      return false;
    else if (__isset.uri && !(uri == rhs.uri))
      return false;
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const germline_dbType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const germline_dbType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(germline_dbType &a, germline_dbType &b);

inline std::ostream& operator<<(std::ostream& out, const germline_dbType& obj)
{
  obj.printTo(out);
  return out;
}


class gl_seg_matchType {
 public:

  gl_seg_matchType(const gl_seg_matchType&);
  gl_seg_matchType& operator=(const gl_seg_matchType&);
  gl_seg_matchType() : aligner_id(0), gl_db_id(0), gl_pos0(0), gl_seg_match_id(0), name(), num_system(), type((Segment_type::type)0) {
  }

  virtual ~gl_seg_matchType() throw();
  int64_t aligner_id;
  int64_t gl_db_id;
  int64_t gl_pos0;
  int64_t gl_seg_match_id;
  std::string name;
  std::string num_system;
  Segment_type::type type;

  void __set_aligner_id(const int64_t val);

  void __set_gl_db_id(const int64_t val);

  void __set_gl_pos0(const int64_t val);

  void __set_gl_seg_match_id(const int64_t val);

  void __set_name(const std::string& val);

  void __set_num_system(const std::string& val);

  void __set_type(const Segment_type::type val);

  bool operator == (const gl_seg_matchType & rhs) const
  {
    if (!(aligner_id == rhs.aligner_id))
      return false;
    if (!(gl_db_id == rhs.gl_db_id))
      return false;
    if (!(gl_pos0 == rhs.gl_pos0))
      return false;
    if (!(gl_seg_match_id == rhs.gl_seg_match_id))
      return false;
    if (!(name == rhs.name))
      return false;
    if (!(num_system == rhs.num_system))
      return false;
    if (!(type == rhs.type))
      return false;
    return true;
  }
  bool operator != (const gl_seg_matchType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const gl_seg_matchType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(gl_seg_matchType &a, gl_seg_matchType &b);

inline std::ostream& operator<<(std::ostream& out, const gl_seg_matchType& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _metaType__isset {
  _metaType__isset() : aligner(false), germline_db(false) {}
  bool aligner :1;
  bool germline_db :1;
} _metaType__isset;

class metaType {
 public:

  metaType(const metaType&);
  metaType& operator=(const metaType&);
  metaType() {
  }

  virtual ~metaType() throw();
  alignerType aligner;
  generatorType generator;
  germline_dbType germline_db;

  _metaType__isset __isset;

  void __set_aligner(const alignerType& val);

  void __set_generator(const generatorType& val);

  void __set_germline_db(const germline_dbType& val);

  bool operator == (const metaType & rhs) const
  {
    if (__isset.aligner != rhs.__isset.aligner)
      return false;
    else if (__isset.aligner && !(aligner == rhs.aligner))
      return false;
    if (!(generator == rhs.generator))
      return false;
    if (__isset.germline_db != rhs.__isset.germline_db)
      return false;
    else if (__isset.germline_db && !(germline_db == rhs.germline_db))
      return false;
    return true;
  }
  bool operator != (const metaType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const metaType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(metaType &a, metaType &b);

inline std::ostream& operator<<(std::ostream& out, const metaType& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _regionType__isset {
  _regionType__isset() : deletions(false), identity(false), insertions(false), inverted(false), mutated_invariant(false), num_system(false), out_frame_indel(false), out_frame_vdj(false), score(false), stop_codon(false), substitutions(false) {}
  bool deletions :1;
  bool identity :1;
  bool insertions :1;
  bool inverted :1;
  bool mutated_invariant :1;
  bool num_system :1;
  bool out_frame_indel :1;
  bool out_frame_vdj :1;
  bool score :1;
  bool stop_codon :1;
  bool substitutions :1;
} _regionType__isset;

class regionType {
 public:

  regionType(const regionType&);
  regionType& operator=(const regionType&);
  regionType() : aligner_id(0), deletions(0), identity(), insertions(0), inverted(0), mutated_invariant(0), name(), num_system(), out_frame_indel(0), out_frame_vdj(0), read_len(0), read_pos0(0), score(0), stop_codon(0), substitutions(0) {
  }

  virtual ~regionType() throw();
  int64_t aligner_id;
  int64_t deletions;
  std::string identity;
  int64_t insertions;
  bool inverted;
  bool mutated_invariant;
  std::string name;
  std::string num_system;
  bool out_frame_indel;
  bool out_frame_vdj;
  int64_t read_len;
  int64_t read_pos0;
  int64_t score;
  bool stop_codon;
  int64_t substitutions;

  _regionType__isset __isset;

  void __set_aligner_id(const int64_t val);

  void __set_deletions(const int64_t val);

  void __set_identity(const std::string& val);

  void __set_insertions(const int64_t val);

  void __set_inverted(const bool val);

  void __set_mutated_invariant(const bool val);

  void __set_name(const std::string& val);

  void __set_num_system(const std::string& val);

  void __set_out_frame_indel(const bool val);

  void __set_out_frame_vdj(const bool val);

  void __set_read_len(const int64_t val);

  void __set_read_pos0(const int64_t val);

  void __set_score(const int64_t val);

  void __set_stop_codon(const bool val);

  void __set_substitutions(const int64_t val);

  bool operator == (const regionType & rhs) const
  {
    if (!(aligner_id == rhs.aligner_id))
      return false;
    if (__isset.deletions != rhs.__isset.deletions)
      return false;
    else if (__isset.deletions && !(deletions == rhs.deletions))
      return false;
    if (__isset.identity != rhs.__isset.identity)
      return false;
    else if (__isset.identity && !(identity == rhs.identity))
      return false;
    if (__isset.insertions != rhs.__isset.insertions)
      return false;
    else if (__isset.insertions && !(insertions == rhs.insertions))
      return false;
    if (__isset.inverted != rhs.__isset.inverted)
      return false;
    else if (__isset.inverted && !(inverted == rhs.inverted))
      return false;
    if (__isset.mutated_invariant != rhs.__isset.mutated_invariant)
      return false;
    else if (__isset.mutated_invariant && !(mutated_invariant == rhs.mutated_invariant))
      return false;
    if (!(name == rhs.name))
      return false;
    if (__isset.num_system != rhs.__isset.num_system)
      return false;
    else if (__isset.num_system && !(num_system == rhs.num_system))
      return false;
    if (__isset.out_frame_indel != rhs.__isset.out_frame_indel)
      return false;
    else if (__isset.out_frame_indel && !(out_frame_indel == rhs.out_frame_indel))
      return false;
    if (__isset.out_frame_vdj != rhs.__isset.out_frame_vdj)
      return false;
    else if (__isset.out_frame_vdj && !(out_frame_vdj == rhs.out_frame_vdj))
      return false;
    if (!(read_len == rhs.read_len))
      return false;
    if (!(read_pos0 == rhs.read_pos0))
      return false;
    if (__isset.score != rhs.__isset.score)
      return false;
    else if (__isset.score && !(score == rhs.score))
      return false;
    if (__isset.stop_codon != rhs.__isset.stop_codon)
      return false;
    else if (__isset.stop_codon && !(stop_codon == rhs.stop_codon))
      return false;
    if (__isset.substitutions != rhs.__isset.substitutions)
      return false;
    else if (__isset.substitutions && !(substitutions == rhs.substitutions))
      return false;
    return true;
  }
  bool operator != (const regionType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const regionType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(regionType &a, regionType &b);

inline std::ostream& operator<<(std::ostream& out, const regionType& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _segment_matchType__isset {
  _segment_matchType__isset() : aa_substitution(false), deletions(false), identity(false), insertions(false), inverted(false), mutated_invariant(false), out_frame_indel(false), out_frame_vdj(false), score(false), stop_codon(false), substitutions(false) {}
  bool aa_substitution :1;
  bool deletions :1;
  bool identity :1;
  bool insertions :1;
  bool inverted :1;
  bool mutated_invariant :1;
  bool out_frame_indel :1;
  bool out_frame_vdj :1;
  bool score :1;
  bool stop_codon :1;
  bool substitutions :1;
} _segment_matchType__isset;

class segment_matchType {
 public:

  segment_matchType(const segment_matchType&);
  segment_matchType& operator=(const segment_matchType&);
  segment_matchType() : btop(), deletions(0), gl_len(0), identity(), insertions(0), inverted(0), mutated_invariant(0), out_frame_indel(0), out_frame_vdj(0), read_len(0), read_pos0(0), score(0), segment_match_id(0), stop_codon(0), substitutions(0) {
  }

  virtual ~segment_matchType() throw();
  std::vector<aa_substitutionType>  aa_substitution;
  std::string btop;
  int64_t deletions;
  int64_t gl_len;
  std::vector<gl_seg_matchType>  gl_seg_match;
  std::string identity;
  int64_t insertions;
  bool inverted;
  bool mutated_invariant;
  bool out_frame_indel;
  bool out_frame_vdj;
  int64_t read_len;
  int64_t read_pos0;
  int64_t score;
  int64_t segment_match_id;
  bool stop_codon;
  int64_t substitutions;

  _segment_matchType__isset __isset;

  void __set_aa_substitution(const std::vector<aa_substitutionType> & val);

  void __set_btop(const std::string& val);

  void __set_deletions(const int64_t val);

  void __set_gl_len(const int64_t val);

  void __set_gl_seg_match(const std::vector<gl_seg_matchType> & val);

  void __set_identity(const std::string& val);

  void __set_insertions(const int64_t val);

  void __set_inverted(const bool val);

  void __set_mutated_invariant(const bool val);

  void __set_out_frame_indel(const bool val);

  void __set_out_frame_vdj(const bool val);

  void __set_read_len(const int64_t val);

  void __set_read_pos0(const int64_t val);

  void __set_score(const int64_t val);

  void __set_segment_match_id(const int64_t val);

  void __set_stop_codon(const bool val);

  void __set_substitutions(const int64_t val);

  bool operator == (const segment_matchType & rhs) const
  {
    if (__isset.aa_substitution != rhs.__isset.aa_substitution)
      return false;
    else if (__isset.aa_substitution && !(aa_substitution == rhs.aa_substitution))
      return false;
    if (!(btop == rhs.btop))
      return false;
    if (__isset.deletions != rhs.__isset.deletions)
      return false;
    else if (__isset.deletions && !(deletions == rhs.deletions))
      return false;
    if (!(gl_len == rhs.gl_len))
      return false;
    if (!(gl_seg_match == rhs.gl_seg_match))
      return false;
    if (__isset.identity != rhs.__isset.identity)
      return false;
    else if (__isset.identity && !(identity == rhs.identity))
      return false;
    if (__isset.insertions != rhs.__isset.insertions)
      return false;
    else if (__isset.insertions && !(insertions == rhs.insertions))
      return false;
    if (__isset.inverted != rhs.__isset.inverted)
      return false;
    else if (__isset.inverted && !(inverted == rhs.inverted))
      return false;
    if (__isset.mutated_invariant != rhs.__isset.mutated_invariant)
      return false;
    else if (__isset.mutated_invariant && !(mutated_invariant == rhs.mutated_invariant))
      return false;
    if (__isset.out_frame_indel != rhs.__isset.out_frame_indel)
      return false;
    else if (__isset.out_frame_indel && !(out_frame_indel == rhs.out_frame_indel))
      return false;
    if (__isset.out_frame_vdj != rhs.__isset.out_frame_vdj)
      return false;
    else if (__isset.out_frame_vdj && !(out_frame_vdj == rhs.out_frame_vdj))
      return false;
    if (!(read_len == rhs.read_len))
      return false;
    if (!(read_pos0 == rhs.read_pos0))
      return false;
    if (__isset.score != rhs.__isset.score)
      return false;
    else if (__isset.score && !(score == rhs.score))
      return false;
    if (!(segment_match_id == rhs.segment_match_id))
      return false;
    if (__isset.stop_codon != rhs.__isset.stop_codon)
      return false;
    else if (__isset.stop_codon && !(stop_codon == rhs.stop_codon))
      return false;
    if (__isset.substitutions != rhs.__isset.substitutions)
      return false;
    else if (__isset.substitutions && !(substitutions == rhs.substitutions))
      return false;
    return true;
  }
  bool operator != (const segment_matchType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const segment_matchType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(segment_matchType &a, segment_matchType &b);

inline std::ostream& operator<<(std::ostream& out, const segment_matchType& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _combinationType__isset {
  _combinationType__isset() : region(false) {}
  bool region :1;
} _combinationType__isset;

class combinationType {
 public:

  combinationType(const combinationType&);
  combinationType& operator=(const combinationType&);
  combinationType() {
  }

  virtual ~combinationType() throw();
  std::vector<regionType>  region;
  std::vector<int64_t>  segments;

  _combinationType__isset __isset;

  void __set_region(const std::vector<regionType> & val);

  void __set_segments(const std::vector<int64_t> & val);

  bool operator == (const combinationType & rhs) const
  {
    if (__isset.region != rhs.__isset.region)
      return false;
    else if (__isset.region && !(region == rhs.region))
      return false;
    if (!(segments == rhs.segments))
      return false;
    return true;
  }
  bool operator != (const combinationType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const combinationType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(combinationType &a, combinationType &b);

inline std::ostream& operator<<(std::ostream& out, const combinationType& obj)
{
  obj.printTo(out);
  return out;
}


class vdj_alignmentType {
 public:

  vdj_alignmentType(const vdj_alignmentType&);
  vdj_alignmentType& operator=(const vdj_alignmentType&);
  vdj_alignmentType() {
  }

  virtual ~vdj_alignmentType() throw();
  std::vector<combinationType>  combination;
  std::vector<segment_matchType>  segment_match;

  void __set_combination(const std::vector<combinationType> & val);

  void __set_segment_match(const std::vector<segment_matchType> & val);

  bool operator == (const vdj_alignmentType & rhs) const
  {
    if (!(combination == rhs.combination))
      return false;
    if (!(segment_match == rhs.segment_match))
      return false;
    return true;
  }
  bool operator != (const vdj_alignmentType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const vdj_alignmentType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(vdj_alignmentType &a, vdj_alignmentType &b);

inline std::ostream& operator<<(std::ostream& out, const vdj_alignmentType& obj)
{
  obj.printTo(out);
  return out;
}

typedef struct _readType__isset {
  _readType__isset() : vdj_alignment(false) {}
  bool vdj_alignment :1;
} _readType__isset;

class readType {
 public:

  readType(const readType&);
  readType& operator=(const readType&);
  readType() : read_id() {
  }

  virtual ~readType() throw();
  std::string read_id;
  vdj_alignmentType vdj_alignment;

  _readType__isset __isset;

  void __set_read_id(const std::string& val);

  void __set_vdj_alignment(const vdj_alignmentType& val);

  bool operator == (const readType & rhs) const
  {
    if (!(read_id == rhs.read_id))
      return false;
    if (__isset.vdj_alignment != rhs.__isset.vdj_alignment)
      return false;
    else if (__isset.vdj_alignment && !(vdj_alignment == rhs.vdj_alignment))
      return false;
    return true;
  }
  bool operator != (const readType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const readType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(readType &a, readType &b);

inline std::ostream& operator<<(std::ostream& out, const readType& obj)
{
  obj.printTo(out);
  return out;
}


class read_resultsType {
 public:

  read_resultsType(const read_resultsType&);
  read_resultsType& operator=(const read_resultsType&);
  read_resultsType() {
  }

  virtual ~read_resultsType() throw();
  readType read;

  void __set_read(const readType& val);

  bool operator == (const read_resultsType & rhs) const
  {
    if (!(read == rhs.read))
      return false;
    return true;
  }
  bool operator != (const read_resultsType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const read_resultsType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(read_resultsType &a, read_resultsType &b);

inline std::ostream& operator<<(std::ostream& out, const read_resultsType& obj)
{
  obj.printTo(out);
  return out;
}


class vdjmlType {
 public:

  vdjmlType(const vdjmlType&);
  vdjmlType& operator=(const vdjmlType&);
  vdjmlType() : version(0) {
  }

  virtual ~vdjmlType() throw();
  metaType meta;
  read_resultsType read_results;
  double version;

  void __set_meta(const metaType& val);

  void __set_read_results(const read_resultsType& val);

  void __set_version(const double val);

  bool operator == (const vdjmlType & rhs) const
  {
    if (!(meta == rhs.meta))
      return false;
    if (!(read_results == rhs.read_results))
      return false;
    if (!(version == rhs.version))
      return false;
    return true;
  }
  bool operator != (const vdjmlType &rhs) const {
    return !(*this == rhs);
  }

  bool operator < (const vdjmlType & ) const;

  uint32_t read(::apache::thrift::protocol::TProtocol* iprot);
  uint32_t write(::apache::thrift::protocol::TProtocol* oprot) const;

  virtual void printTo(std::ostream& out) const;
};

void swap(vdjmlType &a, vdjmlType &b);

inline std::ostream& operator<<(std::ostream& out, const vdjmlType& obj)
{
  obj.printTo(out);
  return out;
}

} // namespace

#endif
