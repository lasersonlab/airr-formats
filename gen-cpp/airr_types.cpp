/**
 * Autogenerated by Thrift Compiler (0.9.3)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "airr_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>

namespace airr {

int _kOriginValues[] = {
  Origin::HUMAN,
  Origin::ANIMAL,
  Origin::SYNTHETIC
};
const char* _kOriginNames[] = {
  "HUMAN",
  "ANIMAL",
  "SYNTHETIC"
};
const std::map<int, const char*> _Origin_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(3, _kOriginValues, _kOriginNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kSexValues[] = {
  Sex::MALE,
  Sex::FEMALE
};
const char* _kSexNames[] = {
  "MALE",
  "FEMALE"
};
const std::map<int, const char*> _Sex_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kSexValues, _kSexNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

int _kLocusValues[] = {
  Locus::IGH,
  Locus::IGK,
  Locus::IGL,
  Locus::TRB,
  Locus::TRA,
  Locus::TRG,
  Locus::TRD
};
const char* _kLocusNames[] = {
  "IGH",
  "IGK",
  "IGL",
  "TRB",
  "TRA",
  "TRG",
  "TRD"
};
const std::map<int, const char*> _Locus_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(7, _kLocusValues, _kLocusNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));


Study::~Study() throw() {
}


void Study::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void Study::__set_title(const std::string& val) {
  this->title = val;
__isset.title = true;
}

void Study::__set_labName(const std::string& val) {
  this->labName = val;
__isset.labName = true;
}

void Study::__set_correspondence(const std::string& val) {
  this->correspondence = val;
__isset.correspondence = true;
}

void Study::__set_doi(const std::string& val) {
  this->doi = val;
__isset.doi = true;
}

uint32_t Study::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->title);
          this->__isset.title = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->labName);
          this->__isset.labName = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->correspondence);
          this->__isset.correspondence = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->doi);
          this->__isset.doi = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Study::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Study");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.title) {
    xfer += oprot->writeFieldBegin("title", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->title);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.labName) {
    xfer += oprot->writeFieldBegin("labName", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->labName);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.correspondence) {
    xfer += oprot->writeFieldBegin("correspondence", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->correspondence);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.doi) {
    xfer += oprot->writeFieldBegin("doi", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->doi);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Study &a, Study &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.title, b.title);
  swap(a.labName, b.labName);
  swap(a.correspondence, b.correspondence);
  swap(a.doi, b.doi);
  swap(a.__isset, b.__isset);
}

Study::Study(const Study& other0) {
  id = other0.id;
  title = other0.title;
  labName = other0.labName;
  correspondence = other0.correspondence;
  doi = other0.doi;
  __isset = other0.__isset;
}
Study& Study::operator=(const Study& other1) {
  id = other1.id;
  title = other1.title;
  labName = other1.labName;
  correspondence = other1.correspondence;
  doi = other1.doi;
  __isset = other1.__isset;
  return *this;
}
void Study::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Study(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "title="; (__isset.title ? (out << to_string(title)) : (out << "<null>"));
  out << ", " << "labName="; (__isset.labName ? (out << to_string(labName)) : (out << "<null>"));
  out << ", " << "correspondence="; (__isset.correspondence ? (out << to_string(correspondence)) : (out << "<null>"));
  out << ", " << "doi="; (__isset.doi ? (out << to_string(doi)) : (out << "<null>"));
  out << ")";
}


Subject::~Subject() throw() {
}


void Subject::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void Subject::__set_origin(const Origin::type val) {
  this->origin = val;
__isset.origin = true;
}

void Subject::__set_sex(const Sex::type val) {
  this->sex = val;
__isset.sex = true;
}

void Subject::__set_age(const int32_t val) {
  this->age = val;
__isset.age = true;
}

uint32_t Subject::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast2;
          xfer += iprot->readI32(ecast2);
          this->origin = (Origin::type)ecast2;
          this->__isset.origin = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast3;
          xfer += iprot->readI32(ecast3);
          this->sex = (Sex::type)ecast3;
          this->__isset.sex = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->age);
          this->__isset.age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Subject::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Subject");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.origin) {
    xfer += oprot->writeFieldBegin("origin", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->origin);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.sex) {
    xfer += oprot->writeFieldBegin("sex", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->sex);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.age) {
    xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I32, 4);
    xfer += oprot->writeI32(this->age);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Subject &a, Subject &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.origin, b.origin);
  swap(a.sex, b.sex);
  swap(a.age, b.age);
  swap(a.__isset, b.__isset);
}

Subject::Subject(const Subject& other4) {
  id = other4.id;
  origin = other4.origin;
  sex = other4.sex;
  age = other4.age;
  __isset = other4.__isset;
}
Subject& Subject::operator=(const Subject& other5) {
  id = other5.id;
  origin = other5.origin;
  sex = other5.sex;
  age = other5.age;
  __isset = other5.__isset;
  return *this;
}
void Subject::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Subject(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "origin="; (__isset.origin ? (out << to_string(origin)) : (out << "<null>"));
  out << ", " << "sex="; (__isset.sex ? (out << to_string(sex)) : (out << "<null>"));
  out << ", " << "age="; (__isset.age ? (out << to_string(age)) : (out << "<null>"));
  out << ")";
}


Sample::~Sample() throw() {
}


void Sample::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void Sample::__set_type(const std::string& val) {
  this->type = val;
__isset.type = true;
}

void Sample::__set_source(const std::string& val) {
  this->source = val;
__isset.source = true;
}

void Sample::__set_dt(const std::string& val) {
  this->dt = val;
__isset.dt = true;
}

uint32_t Sample::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->type);
          this->__isset.type = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->source);
          this->__isset.source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dt);
          this->__isset.dt = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Sample::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Sample");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.type) {
    xfer += oprot->writeFieldBegin("type", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->type);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.source) {
    xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->source);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dt) {
    xfer += oprot->writeFieldBegin("dt", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->dt);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Sample &a, Sample &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.type, b.type);
  swap(a.source, b.source);
  swap(a.dt, b.dt);
  swap(a.__isset, b.__isset);
}

Sample::Sample(const Sample& other6) {
  id = other6.id;
  type = other6.type;
  source = other6.source;
  dt = other6.dt;
  __isset = other6.__isset;
}
Sample& Sample::operator=(const Sample& other7) {
  id = other7.id;
  type = other7.type;
  source = other7.source;
  dt = other7.dt;
  __isset = other7.__isset;
  return *this;
}
void Sample::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Sample(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "type="; (__isset.type ? (out << to_string(type)) : (out << "<null>"));
  out << ", " << "source="; (__isset.source ? (out << to_string(source)) : (out << "<null>"));
  out << ", " << "dt="; (__isset.dt ? (out << to_string(dt)) : (out << "<null>"));
  out << ")";
}


Chain::~Chain() throw() {
}


void Chain::__set_id(const std::string& val) {
  this->id = val;
__isset.id = true;
}

void Chain::__set_ntSeq(const std::string& val) {
  this->ntSeq = val;
__isset.ntSeq = true;
}

void Chain::__set_locus(const Locus::type val) {
  this->locus = val;
__isset.locus = true;
}

void Chain::__set_vAllele(const std::string& val) {
  this->vAllele = val;
__isset.vAllele = true;
}

void Chain::__set_dAllele(const std::string& val) {
  this->dAllele = val;
__isset.dAllele = true;
}

void Chain::__set_jAllele(const std::string& val) {
  this->jAllele = val;
__isset.jAllele = true;
}

void Chain::__set_alignment(const std::string& val) {
  this->alignment = val;
__isset.alignment = true;
}

void Chain::__set_ntCDR3(const std::string& val) {
  this->ntCDR3 = val;
__isset.ntCDR3 = true;
}

uint32_t Chain::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->id);
          this->__isset.id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ntSeq);
          this->__isset.ntSeq = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast8;
          xfer += iprot->readI32(ecast8);
          this->locus = (Locus::type)ecast8;
          this->__isset.locus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->vAllele);
          this->__isset.vAllele = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->dAllele);
          this->__isset.dAllele = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 6:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->jAllele);
          this->__isset.jAllele = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 7:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->alignment);
          this->__isset.alignment = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 8:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->ntCDR3);
          this->__isset.ntCDR3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Chain::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Chain");

  if (this->__isset.id) {
    xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->id);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ntSeq) {
    xfer += oprot->writeFieldBegin("ntSeq", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->ntSeq);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.locus) {
    xfer += oprot->writeFieldBegin("locus", ::apache::thrift::protocol::T_I32, 3);
    xfer += oprot->writeI32((int32_t)this->locus);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.vAllele) {
    xfer += oprot->writeFieldBegin("vAllele", ::apache::thrift::protocol::T_STRING, 4);
    xfer += oprot->writeString(this->vAllele);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.dAllele) {
    xfer += oprot->writeFieldBegin("dAllele", ::apache::thrift::protocol::T_STRING, 5);
    xfer += oprot->writeString(this->dAllele);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.jAllele) {
    xfer += oprot->writeFieldBegin("jAllele", ::apache::thrift::protocol::T_STRING, 6);
    xfer += oprot->writeString(this->jAllele);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.alignment) {
    xfer += oprot->writeFieldBegin("alignment", ::apache::thrift::protocol::T_STRING, 7);
    xfer += oprot->writeString(this->alignment);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.ntCDR3) {
    xfer += oprot->writeFieldBegin("ntCDR3", ::apache::thrift::protocol::T_STRING, 8);
    xfer += oprot->writeString(this->ntCDR3);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Chain &a, Chain &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.ntSeq, b.ntSeq);
  swap(a.locus, b.locus);
  swap(a.vAllele, b.vAllele);
  swap(a.dAllele, b.dAllele);
  swap(a.jAllele, b.jAllele);
  swap(a.alignment, b.alignment);
  swap(a.ntCDR3, b.ntCDR3);
  swap(a.__isset, b.__isset);
}

Chain::Chain(const Chain& other9) {
  id = other9.id;
  ntSeq = other9.ntSeq;
  locus = other9.locus;
  vAllele = other9.vAllele;
  dAllele = other9.dAllele;
  jAllele = other9.jAllele;
  alignment = other9.alignment;
  ntCDR3 = other9.ntCDR3;
  __isset = other9.__isset;
}
Chain& Chain::operator=(const Chain& other10) {
  id = other10.id;
  ntSeq = other10.ntSeq;
  locus = other10.locus;
  vAllele = other10.vAllele;
  dAllele = other10.dAllele;
  jAllele = other10.jAllele;
  alignment = other10.alignment;
  ntCDR3 = other10.ntCDR3;
  __isset = other10.__isset;
  return *this;
}
void Chain::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Chain(";
  out << "id="; (__isset.id ? (out << to_string(id)) : (out << "<null>"));
  out << ", " << "ntSeq="; (__isset.ntSeq ? (out << to_string(ntSeq)) : (out << "<null>"));
  out << ", " << "locus="; (__isset.locus ? (out << to_string(locus)) : (out << "<null>"));
  out << ", " << "vAllele="; (__isset.vAllele ? (out << to_string(vAllele)) : (out << "<null>"));
  out << ", " << "dAllele="; (__isset.dAllele ? (out << to_string(dAllele)) : (out << "<null>"));
  out << ", " << "jAllele="; (__isset.jAllele ? (out << to_string(jAllele)) : (out << "<null>"));
  out << ", " << "alignment="; (__isset.alignment ? (out << to_string(alignment)) : (out << "<null>"));
  out << ", " << "ntCDR3="; (__isset.ntCDR3 ? (out << to_string(ntCDR3)) : (out << "<null>"));
  out << ")";
}


FindCdr3Req::~FindCdr3Req() throw() {
}


void FindCdr3Req::__set_cdr3(const std::string& val) {
  this->cdr3 = val;
}

void FindCdr3Req::__set_locus(const Locus::type val) {
  this->locus = val;
}

void FindCdr3Req::__set_studyIds(const std::vector<std::string> & val) {
  this->studyIds = val;
__isset.studyIds = true;
}

uint32_t FindCdr3Req::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_cdr3 = false;
  bool isset_locus = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cdr3);
          isset_cdr3 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast11;
          xfer += iprot->readI32(ecast11);
          this->locus = (Locus::type)ecast11;
          isset_locus = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->studyIds.clear();
            uint32_t _size12;
            ::apache::thrift::protocol::TType _etype15;
            xfer += iprot->readListBegin(_etype15, _size12);
            this->studyIds.resize(_size12);
            uint32_t _i16;
            for (_i16 = 0; _i16 < _size12; ++_i16)
            {
              xfer += iprot->readString(this->studyIds[_i16]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.studyIds = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_cdr3)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_locus)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FindCdr3Req::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FindCdr3Req");

  xfer += oprot->writeFieldBegin("cdr3", ::apache::thrift::protocol::T_STRING, 1);
  xfer += oprot->writeString(this->cdr3);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("locus", ::apache::thrift::protocol::T_I32, 2);
  xfer += oprot->writeI32((int32_t)this->locus);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.studyIds) {
    xfer += oprot->writeFieldBegin("studyIds", ::apache::thrift::protocol::T_LIST, 3);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->studyIds.size()));
      std::vector<std::string> ::const_iterator _iter17;
      for (_iter17 = this->studyIds.begin(); _iter17 != this->studyIds.end(); ++_iter17)
      {
        xfer += oprot->writeString((*_iter17));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FindCdr3Req &a, FindCdr3Req &b) {
  using ::std::swap;
  swap(a.cdr3, b.cdr3);
  swap(a.locus, b.locus);
  swap(a.studyIds, b.studyIds);
  swap(a.__isset, b.__isset);
}

FindCdr3Req::FindCdr3Req(const FindCdr3Req& other18) {
  cdr3 = other18.cdr3;
  locus = other18.locus;
  studyIds = other18.studyIds;
  __isset = other18.__isset;
}
FindCdr3Req& FindCdr3Req::operator=(const FindCdr3Req& other19) {
  cdr3 = other19.cdr3;
  locus = other19.locus;
  studyIds = other19.studyIds;
  __isset = other19.__isset;
  return *this;
}
void FindCdr3Req::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FindCdr3Req(";
  out << "cdr3=" << to_string(cdr3);
  out << ", " << "locus=" << to_string(locus);
  out << ", " << "studyIds="; (__isset.studyIds ? (out << to_string(studyIds)) : (out << "<null>"));
  out << ")";
}


FindCdr3Resp::~FindCdr3Resp() throw() {
}


void FindCdr3Resp::__set_found(const bool val) {
  this->found = val;
}

void FindCdr3Resp::__set_specificities(const std::vector<std::string> & val) {
  this->specificities = val;
__isset.specificities = true;
}

uint32_t FindCdr3Resp::read(::apache::thrift::protocol::TProtocol* iprot) {

  apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_found = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_BOOL) {
          xfer += iprot->readBool(this->found);
          isset_found = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_LIST) {
          {
            this->specificities.clear();
            uint32_t _size20;
            ::apache::thrift::protocol::TType _etype23;
            xfer += iprot->readListBegin(_etype23, _size20);
            this->specificities.resize(_size20);
            uint32_t _i24;
            for (_i24 = 0; _i24 < _size20; ++_i24)
            {
              xfer += iprot->readString(this->specificities[_i24]);
            }
            xfer += iprot->readListEnd();
          }
          this->__isset.specificities = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_found)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t FindCdr3Resp::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("FindCdr3Resp");

  xfer += oprot->writeFieldBegin("found", ::apache::thrift::protocol::T_BOOL, 1);
  xfer += oprot->writeBool(this->found);
  xfer += oprot->writeFieldEnd();

  if (this->__isset.specificities) {
    xfer += oprot->writeFieldBegin("specificities", ::apache::thrift::protocol::T_LIST, 2);
    {
      xfer += oprot->writeListBegin(::apache::thrift::protocol::T_STRING, static_cast<uint32_t>(this->specificities.size()));
      std::vector<std::string> ::const_iterator _iter25;
      for (_iter25 = this->specificities.begin(); _iter25 != this->specificities.end(); ++_iter25)
      {
        xfer += oprot->writeString((*_iter25));
      }
      xfer += oprot->writeListEnd();
    }
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(FindCdr3Resp &a, FindCdr3Resp &b) {
  using ::std::swap;
  swap(a.found, b.found);
  swap(a.specificities, b.specificities);
  swap(a.__isset, b.__isset);
}

FindCdr3Resp::FindCdr3Resp(const FindCdr3Resp& other26) {
  found = other26.found;
  specificities = other26.specificities;
  __isset = other26.__isset;
}
FindCdr3Resp& FindCdr3Resp::operator=(const FindCdr3Resp& other27) {
  found = other27.found;
  specificities = other27.specificities;
  __isset = other27.__isset;
  return *this;
}
void FindCdr3Resp::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "FindCdr3Resp(";
  out << "found=" << to_string(found);
  out << ", " << "specificities="; (__isset.specificities ? (out << to_string(specificities)) : (out << "<null>"));
  out << ")";
}

} // namespace
